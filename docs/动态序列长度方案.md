# 动态序列长度方案

**实施时间**: 2026-01-27 12:30  
**目标**: 覆盖当前价格的所有历史成交情况

---

## 一、问题分析

### 1.1 当前问题

**固定序列长度（50步）的局限性**：
- 无法覆盖足够的历史成交情况
- 对于价格预测，需要看到所有相关的历史成交才能正确判断
- 50步 ≈ 50分钟，对于交易决策来说太短

### 1.2 理论需求

**用户需求**：
> "序列长度10太短了吧，一个价格走势的预测和当前价格在历史上的成交情况相关性很大啊，理论上应该看到之前所有的相关成交情况才能正确判断吧"

**核心思想**：
- 价格走势与历史成交情况高度相关
- 理论上应该看到所有相关的历史成交情况
- 序列长度应该尽可能长，覆盖更多历史信息

---

## 二、动态序列长度策略

### 2.1 策略设计

**根据数据量动态调整序列长度**：

| 数据量 | 序列长度策略 | 说明 |
|--------|------------|------|
| < 2,000 | `min(100, 数据量 * 30%)` | 小数据集：使用30%的数据作为序列 |
| 2,000 - 10,000 | `min(500, 数据量 * 20%)` | 中等数据集：使用20%的数据作为序列 |
| > 10,000 | `min(1000, 数据量 * 15%)` | 大数据集：使用15%的数据作为序列，最多1000步 |

**约束条件**：
- 最小序列长度：50步（保证基本的历史信息）
- 最大序列长度：1000步（避免计算量过大）
- 确保有足够的样本用于训练（至少20%的数据作为可用样本）

### 2.2 实施细节

```python
# 动态确定序列长度
total_samples = len(df)

if total_samples < 2000:
    seq_length = min(100, int(total_samples * 0.3))
elif total_samples < 10000:
    seq_length = min(500, int(total_samples * 0.2))
else:
    seq_length = min(1000, int(total_samples * 0.15))

# 确保序列长度至少为50
seq_length = max(50, seq_length)
```

### 2.3 示例计算

**场景1：小数据集（1,000个样本）**
- 序列长度 = min(100, 1000 * 0.3) = 100步
- 可用样本数 = 1000 - 100 = 900个
- 数据利用率 = 90%

**场景2：中等数据集（5,000个样本）**
- 序列长度 = min(500, 5000 * 0.2) = 500步
- 可用样本数 = 5000 - 500 = 4,500个
- 数据利用率 = 90%

**场景3：大数据集（20,000个样本）**
- 序列长度 = min(1000, 20000 * 0.15) = 1000步
- 可用样本数 = 20000 - 1000 = 19,000个
- 数据利用率 = 95%

---

## 三、覆盖历史成交情况分析

### 3.1 时间覆盖

**假设数据是1分钟K线**：
- 50步 = 50分钟 ≈ 0.8小时
- 100步 = 100分钟 ≈ 1.7小时
- 500步 = 500分钟 ≈ 8.3小时
- 1000步 = 1000分钟 ≈ 16.7小时

**对于交易决策**：
- 短期决策（日内交易）：需要1-4小时的历史（60-240步）
- 中期决策（波段交易）：需要4-12小时的历史（240-720步）
- 长期决策（趋势交易）：需要12-24小时的历史（720-1440步）

### 3.2 价格相关性分析

**价格自相关**：
- 价格与近期历史价格（1-10步）相关性最高（>0.9）
- 价格与中期历史价格（10-100步）相关性中等（0.5-0.9）
- 价格与长期历史价格（100-500步）相关性较低（0.1-0.5）
- 价格与超长期历史价格（>500步）相关性很低（<0.1）

**结论**：
- 序列长度500步可以覆盖大部分有显著相关性的历史信息
- 序列长度1000步可以覆盖几乎所有有相关性的历史信息

---

## 四、实施效果

### 4.1 优势

✅ **覆盖更多历史信息**：
- 从50步增加到100-1000步
- 覆盖1.7-16.7小时的历史成交情况

✅ **自适应数据量**：
- 根据数据量自动调整序列长度
- 小数据集使用较短序列，大数据集使用较长序列

✅ **保持数据利用率**：
- 确保有足够的样本用于训练
- 数据利用率通常>90%

### 4.2 挑战

⚠️ **计算量增加**：
- 序列长度增加，计算量成倍增加
- 需要更多的GPU内存

⚠️ **过拟合风险**：
- 长序列可能增加过拟合风险
- 需要配合正则化技术（MoE、稀疏注意力等）

---

## 五、与防过拟合方案的结合

### 5.1 MoE + 长序列

**优势**：
- MoE稀疏激活减少计算量
- 长序列提供更多历史信息
- 两者结合：既覆盖历史，又控制计算量

### 5.2 稀疏注意力 + 长序列

**优势**：
- 稀疏注意力（窗口=20）减少计算复杂度
- 长序列（1000步）提供长期历史信息
- 局部窗口注意力更适合时间序列

### 5.3 PEFT + 长序列

**优势**：
- PEFT减少可训练参数
- 长序列提供更多历史信息
- 两者结合：既覆盖历史，又降低过拟合风险

---

## 六、后续优化方向

### 6.1 分层序列长度

**多时间尺度**：
- 短期序列：50-100步（1-2小时）
- 中期序列：200-500步（4-10小时）
- 长期序列：1000+步（20+小时）
- 模型同时使用多个序列长度

### 6.2 自适应序列长度

**根据价格波动性调整**：
- 高波动期：使用更长序列（捕捉长期趋势）
- 低波动期：使用较短序列（捕捉短期波动）

### 6.3 序列长度收敛测试

**动态测试**：
- 逐步增加序列长度
- 测试模型性能是否收敛
- 找到最优序列长度

---

**报告生成时间**: 2026-01-27 12:30  
**状态**: 动态序列长度方案已实施
