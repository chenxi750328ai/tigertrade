# 订单执行流程说明（基于 src/tiger1.py）

## 1. tiger1.py 里订单怎么执行的

### 入口：`place_tiger_order(side, quantity, price, stop_loss_price=None, take_profit_price=None, ...)`

1. **环境与风控**
   - `RUN_ENV == 'production'` 且 `ALLOW_REAL_TRADING != '1'` → 直接拒绝下单，返回 False。
   - `api_manager.is_mock_mode == True` → 走模拟：只打日志、更新本地状态，不调真实 API。

2. **真实下单分支（非 mock）**
   - 用 `trade_api = api_manager.trade_api`（即 `api_adapter` 里的 RealTradeApiAdapter）。
   - 若 `trade_api is None`，会用 `trade_client` / `quote_client` 和 `client_config.account` 调 `api_manager.initialize_real_apis(...)` 再取 `trade_api`。
   - 准备参数：
     - `symbol_for_api = _to_api_identifier(FUTURE_SYMBOL)` → 例如 `SIL.COMEX.202603` → `SIL2603`。
     - 有价格 → `OrderType.LMT`、`limit_price=price`；无价格 → `OrderType.MKT`、`limit_price=None`。
     - `order_side = OrderSide.BUY` 或 `OrderSide.SELL`。
   - **实际调用**（约 1449–1456 行）：
     ```python
     order_result = trade_api.place_order(
         symbol=symbol_for_api,   # SIL2603
         side=order_side,
         order_type=order_type,
         quantity=quantity,
         time_in_force=TimeInForce.DAY,
         limit_price=limit_price,
         stop_price=None
     )
     ```
   - 这里 **没有显式传 account**：account 在 `api_manager` 初始化时已经交给 `trade_api`，由 `api_adapter` 内部使用。

3. **下单成功后**
   - 从 `order_result` 里取 `order_id`（支持对象或 dict）。
   - 更新 `current_position`、`open_orders`、`position_entry_times`、`position_entry_prices` 等内存状态。
   - 返回 True。

---

## 2. api_adapter 里真实下单（RealTradeApiAdapter.place_order）

- **入参**：`symbol, side, order_type, quantity, time_in_force, limit_price=None, stop_price=None`（与 tiger1 调用一致）。
- **account 来源**（按顺序）：
  1. `self.account`（初始化 RealTradeApiAdapter 时传入）；
  2. `self.client.account` 或 `self.client.config.account`；
  3. `api_manager._account` 或 `api_manager.trade_api.account`。
- **合约**：`future_contract(symbol=symbol_to_use, currency=Currency.USD)`，例如 SIL2603 + USD。
- **订单**：`limit_order(account=account, contract=contract, action=side, limit_price=limit_price, quantity=quantity)`（或市价用 `market_order`）。
- **最终调用**：`self.client.place_order(order)`，即 Tiger SDK 的 `TradeClient.place_order(order)`。

也就是说：**tiger1 只负责组参数并调 `trade_api.place_order(...)`；account、合约、Order 对象都在 api_adapter 里完成，再交给底层 client。**

---

## 3. order_executor 与 tiger1 的关系

- `OrderExecutor.execute_buy` 会做风控、止损/止盈计算，然后也是调 **同一个** `api_manager.trade_api.place_order(...)`，只是用**位置参数**：
  `place_order(symbol_to_use, order_side, order_type, order_quantity, TimeInForce.DAY, price, None)`。
- 因此和 tiger1 的 `place_tiger_order` 走的是**同一套真实下单路径**（同一 adapter、同一 account 来源、同一 `client.place_order(order)`）。

---

## 4. 当前报错「account 未授权」说明

- 日志里能看到：`account=21415812702670778`，`symbol=SIL2603`，Order 构造和调用都正常。
- Tiger 返回：`account '21415812702670778' is not authorized to the api user`。
- **结论**：问题不在 tiger1 或 api_adapter 的代码逻辑，而是 **Tiger 后台没有把该 account 授权给当前使用的 API 用户（当前 API Key）**。
- **处理方式**：在 Tiger 开放平台后台，给当前 API 用户增加对 account `21415812702670778` 的授权；授权完成后，同一套代码（tiger1 / order_executor / 测试）应能正常下单、查询。

---

## 5. 小结

| 步骤 | 位置 | 说明 |
|------|------|------|
| 入口 | tiger1.place_tiger_order | 风控、mock 判断，组 symbol/side/type/quantity/time_in_force/limit_price |
| 调用 | trade_api.place_order(...) | 即 api_adapter.RealTradeApiAdapter.place_order |
| account | api_adapter | 从 self/client/api_manager 取，不在此处传 |
| 合约 | api_adapter | future_contract(symbol=SIL2603, currency=USD) |
| 订单 | api_adapter | limit_order(account, contract, action, limit_price, quantity) |
| 发送 | api_adapter | self.client.place_order(order) → Tiger 真实下单 |

订单没搞定的根因是：**Tiger 后台未对该 API 用户授权 account**，需在后台配置授权后再测。
