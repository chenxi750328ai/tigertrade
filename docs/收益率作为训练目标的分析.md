# 收益率作为训练目标的分析

**更新时间**: 2026-01-23

---

## 🤔 一、问题提出

**当前方法**：使用分类任务（CrossEntropyLoss）预测动作（买入/卖出/不操作）

**用户建议**：直接用收益率作为目标来训练（回归任务）

**核心问题**：为什么不用收益率作为目标来训练呢？

---

## 📊 二、当前方法 vs 收益率回归方法

### 2.1 当前方法（分类任务）

**损失函数**：
```python
loss = CrossEntropyLoss(action_logits, action_labels)
```

**目标**：预测离散动作（0=不操作, 1=买入, 2=卖出）

**标签生成**：
```python
# 基于未来10步价格变化，计算买入和卖出收益
buy_profit = (max(future_prices) - current_price) / current_price
sell_profit = (current_price - min(future_prices)) / current_price

# 选择收益最大的动作作为标签
if buy_profit > sell_profit and buy_profit > 0.5%:
    label = 1  # 买入
elif sell_profit > buy_profit and sell_profit > 0.5%:
    label = 2  # 卖出
else:
    label = 0  # 不操作
```

**优点**：
- ✅ 离散动作，容易执行
- ✅ 有明确的交易决策
- ✅ 可以处理"不操作"的情况
- ✅ 训练稳定（分类任务通常比回归任务稳定）

**缺点**：
- ❌ 损失函数不直接优化收益
- ❌ 准确率可能虚高（如果总是预测"不操作"）
- ❌ 可能错过一些小的交易机会（阈值0.5%）
- ❌ 无法预测收益大小，只能预测方向

---

### 2.2 收益率回归方法（建议）

**损失函数**：
```python
loss = MSELoss(predicted_profit, actual_profit)
# 或者
loss = -predicted_profit  # 直接最大化收益（强化学习思路）
```

**目标**：预测收益率（连续值）

**标签生成**：
```python
# 直接使用未来10步的最大可能收益
buy_profit = (max(future_prices) - current_price) / current_price
sell_profit = (current_price - min(future_prices)) / current_price
actual_profit = max(buy_profit, sell_profit)  # 作为回归目标
```

**优点**：
- ✅ **直接优化收益目标**（这是最重要的！）
- ✅ 损失函数更贴近实际目标
- ✅ 可以预测收益大小，而不仅仅是方向
- ✅ 不需要阈值，可以捕捉小的交易机会
- ✅ 更符合交易的本质（目标是收益，不是准确率）

**缺点**：
- ❌ 需要将收益率转换为动作（需要阈值）
- ❌ 可能预测负收益，如何处理？
- ❌ 训练可能不稳定（收益率波动大）
- ❌ 如何处理"不操作"的情况？

---

## 🎯 三、收益率回归方法的实现方案

### 3.1 方案1：直接预测收益率（回归任务）

**模型输出**：
```python
class TradingLSTM(nn.Module):
    def __init__(self, ...):
        ...
        self.profit_head = nn.Linear(hidden_size, 1)  # 预测收益率
    
    def forward(self, x):
        ...
        profit = self.profit_head(out)  # 预测收益率
        return profit
```

**损失函数**：
```python
# 方案1：MSE损失
loss = MSELoss(predicted_profit, actual_profit)

# 方案2：负收益损失（直接最大化收益）
loss = -predicted_profit  # 如果predicted_profit是正收益，loss是负的

# 方案3：Huber损失（对异常值更鲁棒）
loss = HuberLoss(predicted_profit, actual_profit)
```

**动作决策**：
```python
# 预测收益率后，转换为动作
if predicted_profit > 0.005:  # 0.5%阈值
    if buy_profit > sell_profit:
        action = 1  # 买入
    else:
        action = 2  # 卖出
else:
    action = 0  # 不操作
```

---

### 3.2 方案2：预测买入和卖出收益率（多输出回归）

**模型输出**：
```python
class TradingLSTM(nn.Module):
    def __init__(self, ...):
        ...
        self.buy_profit_head = nn.Linear(hidden_size, 1)   # 预测买入收益率
        self.sell_profit_head = nn.Linear(hidden_size, 1)   # 预测卖出收益率
    
    def forward(self, x):
        ...
        buy_profit = self.buy_profit_head(out)
        sell_profit = self.sell_profit_head(out)
        return buy_profit, sell_profit
```

**损失函数**：
```python
# 预测买入和卖出收益率
predicted_buy_profit, predicted_sell_profit = model(x)

# 实际买入和卖出收益率
actual_buy_profit = (max(future_prices) - current_price) / current_price
actual_sell_profit = (current_price - min(future_prices)) / current_price

# 组合损失
loss = MSELoss(predicted_buy_profit, actual_buy_profit) + \
       MSELoss(predicted_sell_profit, actual_sell_profit)
```

**动作决策**：
```python
# 选择收益更大的动作
if predicted_buy_profit > predicted_sell_profit and predicted_buy_profit > 0.005:
    action = 1  # 买入
elif predicted_sell_profit > predicted_buy_profit and predicted_sell_profit > 0.005:
    action = 2  # 卖出
else:
    action = 0  # 不操作
```

---

### 3.3 方案3：强化学习思路（直接优化收益）

**损失函数**：
```python
# 直接最大化预测收益
loss = -predicted_profit  # 如果predicted_profit是正收益，loss是负的

# 或者使用策略梯度
# 如果预测正确（收益>0），增加该预测的概率
# 如果预测错误（收益<0），减少该预测的概率
```

**优点**：
- ✅ 直接优化收益目标
- ✅ 不需要标签（无监督学习）
- ✅ 可以处理负收益

**缺点**：
- ❌ 训练不稳定
- ❌ 需要大量数据
- ❌ 实现复杂

---

## 🔧 四、推荐的实现方案

### 4.1 混合方案（推荐）

**结合分类和回归**：
```python
class TradingLSTM(nn.Module):
    def __init__(self, ...):
        ...
        self.action_head = nn.Linear(hidden_size, 3)      # 预测动作（分类）
        self.profit_head = nn.Linear(hidden_size, 1)      # 预测收益率（回归）
    
    def forward(self, x):
        ...
        action_logits = self.action_head(out)
        profit = self.profit_head(out)
        return action_logits, profit
```

**损失函数**：
```python
# 分类损失（预测动作）
action_loss = CrossEntropyLoss(action_logits, action_labels)

# 回归损失（预测收益率）
profit_loss = MSELoss(predicted_profit, actual_profit)

# 组合损失（收益率损失权重更高）
loss = action_loss + 0.5 * profit_loss  # 收益率损失权重0.5
```

**优点**：
- ✅ 既有明确的动作决策（分类）
- ✅ 又直接优化收益目标（回归）
- ✅ 训练稳定
- ✅ 可以预测收益大小

---

### 4.2 纯收益率回归方案

**模型输出**：
```python
class TradingLSTM(nn.Module):
    def __init__(self, ...):
        ...
        self.profit_head = nn.Linear(hidden_size, 1)  # 预测收益率
    
    def forward(self, x):
        ...
        profit = self.profit_head(out)
        return profit
```

**损失函数**：
```python
# 使用Huber损失（对异常值更鲁棒）
loss = HuberLoss(predicted_profit, actual_profit, delta=0.01)
```

**动作决策**：
```python
# 预测收益率后，转换为动作
predicted_profit = model(x)

# 计算买入和卖出收益
buy_profit = (max(future_prices) - current_price) / current_price
sell_profit = (current_price - min(future_prices)) / current_price

# 如果预测收益率>0.5%，执行交易
if predicted_profit > 0.005:
    if buy_profit > sell_profit:
        action = 1  # 买入
    else:
        action = 2  # 卖出
else:
    action = 0  # 不操作
```

---

## 📊 五、对比总结

| 方法 | 损失函数 | 优点 | 缺点 |
|------|---------|------|------|
| **当前方法（分类）** | CrossEntropyLoss | 训练稳定，有明确动作 | 不直接优化收益 |
| **收益率回归** | MSELoss/HuberLoss | 直接优化收益 | 需要阈值转换动作 |
| **混合方案** | CrossEntropyLoss + MSELoss | 既有动作又有收益 | 实现复杂 |
| **强化学习** | -predicted_profit | 直接优化收益 | 训练不稳定 |

---

## 🎯 六、建议

### 6.1 短期建议

**实现混合方案**：
- 保留分类任务（预测动作）
- 添加回归任务（预测收益率）
- 组合损失：`loss = action_loss + 0.5 * profit_loss`

**优点**：
- ✅ 向后兼容（不影响现有代码）
- ✅ 直接优化收益目标
- ✅ 训练稳定

### 6.2 长期建议

**逐步迁移到纯收益率回归**：
- 移除分类任务
- 只预测收益率
- 使用Huber损失（对异常值更鲁棒）

**优点**：
- ✅ 更符合交易的本质（目标是收益）
- ✅ 不需要阈值（可以捕捉小的交易机会）
- ✅ 损失函数更贴近实际目标

---

## ✅ 七、结论

**用户的问题很有道理**：直接用收益率作为目标来训练，确实更符合交易的本质。

**当前方法的问题**：
- 损失函数不直接优化收益
- 准确率可能虚高
- 可能错过小的交易机会

**建议**：
1. **短期**：实现混合方案（分类+回归）
2. **长期**：逐步迁移到纯收益率回归

**核心思想**：**损失函数应该直接优化我们真正关心的目标（收益），而不是间接目标（准确率）**。

---

**状态**: 分析完成，建议实现混合方案或纯收益率回归方案
