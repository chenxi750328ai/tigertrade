
import sys
import os
import time
import random
import json
import logging
import hmac
import hashlib
import math
from datetime import datetime, timedelta, date, timezone
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Tuple, Optional, Any
import pandas as pd
import numpy as np
import talib
import traceback
from collections import deque
from dotenv import load_dotenv

# Tiger Open API imports
from tigeropen.common.consts import Language, Market, BarPeriod, QuoteRight
from tigeropen.common.consts import OrderStatus, OrderType, Currency
from tigeropen.common.util.contract_utils import stock_contract
from tigeropen.trade.trade_client import TradeClient

# å¯¼å…¥APIé€‚é…å™¨
try:
    from .api_adapter import api_manager
except ImportError:
    try:
        # å¦‚æœç›¸å¯¹å¯¼å…¥å¤±è´¥ï¼Œå°è¯•ç»å¯¹å¯¼å…¥
        from tigertrade.api_adapter import api_manager
    except ImportError:
        # å¦‚æœä½œä¸ºè„šæœ¬ç›´æ¥è¿è¡Œï¼Œéœ€è¦æ·»åŠ å½“å‰ç›®å½•åˆ°sys.path
        import sys
        import os
        sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
        from api_adapter import api_manager

# ä¸ºOrderSideå’ŒTimeInForceåˆ›å»ºæ¨¡æ‹Ÿç±»ï¼Œå¦‚æœæ— æ³•å¯¼å…¥
try:
    from tigeropen.common.consts import OrderSide, TimeInForce
except ImportError:
    class OrderSide:
        BUY = 'BUY'
        SELL = 'SELL'
    
    class TimeInForce:
        DAY = 'DAY'
        GTC = 'GTC'
        IOC = 'IOC'
        OPG = 'OPG'
        FOK = 'FOK'
        GTX = 'GTX'
        GTD = 'GTD'

# åˆå§‹åŒ–é…ç½®å’Œå®¢æˆ·ç«¯
from tigeropen.tiger_open_config import TigerOpenClientConfig
from tigeropen.common.util.signature_utils import read_private_key
from tigeropen.quote.quote_client import QuoteClient
from tigeropen.trade.trade_client import TradeClient

# module logger
logger = logging.getLogger(__name__)
from tigeropen.trade.trade_client import TradeClient

# module logger
logger = logging.getLogger(__name__)

# æ¨¡å—è¯´æ˜ï¼ˆä¸­æ–‡ï¼‰
# æœ¬æ¨¡å—å®ç°äº†ä¸€ä¸ªç®€å•çš„æœŸè´§ç½‘æ ¼äº¤æ˜“ç­–ç•¥åŸå‹ï¼ŒåŒ…å«ï¼š
# - è¡Œæƒ…æ•°æ®è·å–ä¸æ—¶åŒº/æ ¼å¼æ ‡å‡†åŒ–ï¼ˆ`get_kline_data`ï¼‰
# - æŠ€æœ¯æŒ‡æ ‡è®¡ç®—ï¼ˆBOLL, ATR, RSI ç­‰ï¼Œ`calculate_indicators`ï¼‰
# - é£æ§æ£€æŸ¥ï¼ˆ`check_risk_control`ï¼‰
# - ä¸‹å•å°è£…ï¼ˆ`place_tiger_order`ã€`place_take_profit_order`ï¼‰
# - å‡ ç§ç­–ç•¥å®ç°ï¼š`grid_trading_strategy`, `grid_trading_strategy_pro1`, `boll1m_grid_strategy`
#
# è®¾è®¡è¦ç‚¹ï¼ˆä¸­æ–‡æ€»ç»“ï¼‰:
# - åœ¨ import æ—¶å°½é‡ä¿æŒè½»é‡ï¼ˆé¿å…åœ¨æ¨¡å—å¯¼å…¥é˜¶æ®µè§¦å‘çœŸå®ç½‘ç»œ/æ–‡ä»¶IOï¼‰
# - åœ¨ sandbox ç¯å¢ƒï¼ˆæ¨¡æ‹Ÿï¼‰ä¸‹ï¼Œå¤±è´¥çš„ä¸‹å•ä¼šè¢«æ¨¡æ‹Ÿä¸ºæˆåŠŸä»¥æ–¹ä¾¿å›æµ‹/å¼€å‘
# - å¯¹äºè¡Œæƒ…æ—¶é—´æˆ³åšäº†å¥å£®çš„è§£æä¸æ—¶åŒºè½¬æ¢ï¼ˆé»˜è®¤å‡å®šè¿”å›ä¸º UTCï¼‰
# - é’ˆå¯¹æ­¢ç›ˆå•æäº¤å¢åŠ äº†å¯¹æœ€å°å˜åŠ¨ä»·ä½ï¼ˆtick sizeï¼‰çš„è‡ªåŠ¨ä¿®æ­£ä¸é‡è¯•é€»è¾‘
#
# ç®—æ³•æ€»ä½“ä¸å®ç°ç»†èŠ‚ï¼ˆä¸­æ–‡è¯¦è§£ï¼‰
# ä¸‹é¢çš„å†…å®¹ç»™å‡ºç­–ç•¥æ ¸å¿ƒç®—æ³•çš„é€æ­¥è¯´æ˜ï¼Œä¾¿äºé˜…è¯»ä¸åç»­ç»´æŠ¤ï¼š
#
# 1) ç›®æ ‡ä¸è®¾è®¡ï¼š
#    - ç›®æ ‡ï¼šåŸºäº Bollinger Bands ä¸ ATR çš„å¤šå±‚ç¡®è®¤æœºåˆ¶å®ç°ç¨³å¥çš„æœŸè´§ç½‘æ ¼å¼€ä»“/å¹³ä»“é€»è¾‘ï¼Œ
#      å…¼é¡¾æˆäº¤æ¦‚ç‡ä¸é£æ§ï¼ˆæ­¢æŸ/å•ç¬”äºæŸ/å½“æ—¥äºæŸ/ä»“ä½é™åˆ¶ï¼‰ã€‚
#    - è®¾è®¡åŸåˆ™ï¼šå°½é‡ä¿æŒè¿è¡Œæ—¶å¯æ§ï¼ˆsandbox æ¨¡å¼ä¸‹æ¨¡æ‹Ÿä¸‹å•ï¼‰ï¼Œå¹¶å¯¹ç¬¬ä¸‰æ–¹ SDK çš„
#      å¤šç§è¿”å›æ ¼å¼ï¼ˆDataFrame/iterable/by-pageï¼‰åšå…¼å®¹å¤„ç†ã€‚
#
# 2) æ ¸å¿ƒæ•°æ®æµï¼š
#    - ä»è¡Œæƒ…ç«¯è·å– 1 åˆ†é’Ÿä¸ 5 åˆ†é’Ÿ K çº¿ï¼ˆ`get_kline_data`ï¼‰ï¼Œåšæ—¶åŒºä¸æ—¶é—´å•ä½å½’ä¸€åŒ–ï¼ˆUTC -> Asia/Shanghaiï¼‰ï¼Œ
#      å¹¶ä¿è¯æœ€å°‘æ•°æ®é‡é˜ˆå€¼ï¼ˆ`MIN_KLINES`ï¼‰ä»¥é¿å…ç©ºå€¼ã€çŸ­æœŸæ ·æœ¬å¤±çœŸã€‚
#    - åŸºäº 5 åˆ†é’Ÿæ•°æ®è®¡ç®— Bollinger Bands ä¸ ATRï¼ˆ`calculate_indicators`ï¼‰ï¼Œå¹¶åŸºäº 1 åˆ†é’Ÿæ•°æ®
#      è®¡ç®—çŸ­å‘¨æœŸ RSI ä¸æˆäº¤é‡ï¼Œç”¨äºå…¥åœº/é€€å‡ºçš„å³æ—¶åˆ¤æ–­ã€‚
#
# 3) ç½‘æ ¼ç¡®å®šä¸åŠ¨æ€è°ƒæ•´ï¼š
#    - ä½¿ç”¨ 5 åˆ†é’Ÿ Boll ä¸­è½¨/ä¸Šè½¨/ä¸‹è½¨ä½œä¸ºåŸºå‡†ç½‘æ ¼è¾¹ç•Œï¼ˆ`grid_lower`, `grid_upper`ï¼‰ï¼Œ
#      å¹¶ç»“åˆ ATR åšå¾®è°ƒä»¥è€ƒè™‘å½“å‰æ³¢åŠ¨ç‡ã€‚
#    - åœ¨ BOLL å‘æ•£æˆ– ATR æ”¾å¤§æ—¶ï¼Œè°ƒæ•´ç½‘æ ¼ä»¥å‡å°‘é¢‘ç¹è¿›å‡ºå¯¼è‡´çš„æ»‘ç‚¹ä¸æ‰‹ç»­è´¹æŸè€—ã€‚
#
# 4) å¼€ä»“é€»è¾‘ï¼ˆBuy æ¡ä»¶ç¤ºä¾‹ï¼‰ï¼š
#    - åŸºçº¿ï¼šä»·æ ¼æ¥è¿‘æˆ–ä½äº `grid_lower` ä¸” 1 åˆ†é’Ÿ RSI å¤„äºä½ä½ï¼ˆä¸åŒè¶‹åŠ¿ä¸‹é˜ˆå€¼ä¸åŒï¼‰ï¼›
#    - é¢å¤–å…è®¸æ¡ä»¶ï¼ˆpro1ï¼‰ï¼šçŸ­æœŸ RSI åè½¬ã€ä»·æ ¼/RSI èƒŒç¦»ã€æˆ–æˆäº¤é‡çªå¢ä¹‹ä¸€å¯æ”¾å®½å…¥åœºï¼›
#    - æœ€ç»ˆè¿›å…¥å‰æ‰§è¡Œ `check_risk_control`ï¼šæ ¡éªŒä»“ä½ä¸Šé™ã€å•ç¬”å¯èƒ½æŸå¤±ï¼ˆåŸºäº ATR ä¸åˆçº¦ä¹˜æ•°ï¼‰ã€å½“æ—¥äºæŸä¸Šé™ç­‰ã€‚
#
# 5) æ­¢ç›ˆ/æ­¢æŸç­–ç•¥ï¼š
#    - æ­¢æŸï¼šåŸºäº ATR å€æ•°å¹¶å¯¹ä½æ³¢åŠ¨åŠ è®¾ ATR ä¸‹é™ï¼ŒåŒæ—¶åœ¨ BOLL ä¸‹è½¨ä¸‹æ–¹ç•™å‡ºç»“æ„ç¼“å†²ï¼›
#    - æ­¢ç›ˆï¼šä»¥ `grid_upper` å‡å»åŸºäº ATR çš„åç§»é‡æˆ–è‡³å°‘ä¸€ä¸ªæœ€å° tick è®¾ç½®ç›®æ ‡ä»·ï¼Œæé«˜å¯æˆäº¤æ¦‚ç‡ï¼›
#    - æ­¢ç›ˆå•æäº¤ï¼šè‹¥ä¸»å•æ— æ³•ç›´æ¥åŒ…å«åˆ©æ¶¦è…¿ï¼Œä¼šè°ƒç”¨ `place_take_profit_order` å•ç‹¬ä¸‹ TPï¼Œ
#      å¹¶å…·å¤‡å¯¹è¢«æ‹’ç»ï¼ˆä¾‹å¦‚ tick-size ä¸åŒ¹é…ï¼‰æ—¶çš„è‡ªåŠ¨å‘æœ€è¿‘ tick å¯¹é½å¹¶é‡è¯•ä¸€æ¬¡çš„å®¹é”™é€»è¾‘ã€‚
#
# 6) ä¸‹å•å®¹é”™ä¸æ¨¡æ‹Ÿï¼š
#    - ä¼˜å…ˆä½¿ç”¨ SDK çš„åˆçº¦/ä¸‹å•å¸®åŠ©å‡½æ•°ï¼ˆè‹¥å¯ç”¨ï¼‰ï¼Œå¦åˆ™æ„é€  `SimpleNamespace` æ¥å…¼å®¹ `trade_client.place_order` çš„å‚æ•°ã€‚
#    - åœ¨ sandbox ç¯å¢ƒä¸­ï¼Œä¸‹å•å¤±è´¥ä¼šè¢«æ¨¡æ‹Ÿä¸ºæˆåŠŸï¼ˆä»¥ä¾¿ç¦»çº¿å¼€å‘/å›æµ‹ï¼‰ï¼Œè€Œ production æ¨¡å¼ä¸‹è‹¥æœªå¼€å¯
#      `ALLOW_REAL_TRADING=1` åˆ™æ‹’ç»çœŸå®ä¸‹å•ä»¥é¿å…è¯¯æ“ä½œã€‚
#
# 7) å¯æµ‹è¯•æ€§ä¸å·¥ç¨‹å®è·µï¼š
#    - å‡½æ•°å°½é‡ä¿æŒå‰¯ä½œç”¨å¯æ§ï¼ˆä¾‹å¦‚é€šè¿‡æ¨¡å—çº§å˜é‡ä¿å­˜ç®€è¦çŠ¶æ€ï¼‰ï¼Œå¹¶åœ¨æµ‹è¯•ä¸­é€šè¿‡ monkeypatch æ¨¡æ‹Ÿ
#      `quote_client` / `trade_client` çš„è¡Œä¸ºæ¥éªŒè¯ä¸åŒè·¯å¾„ã€‚
#    - å¯¹æ—¶é—´æˆ³è§£æã€åˆ†é¡µé€»è¾‘ã€ä»¥åŠä¸åŒ SDK è¿”å›æ ¼å¼å¢åŠ äº†å…¼å®¹æ€§ä»£ç ä¸æ—¥å¿—ï¼Œä¾¿äºæ’æŸ¥çº¿ä¸Šå·®å¼‚ã€‚

# Read command-line mode when running as a script, but be import-safe for tests
count_type = sys.argv[1] if len(sys.argv) > 1 and sys.argv[1] in ('d', 'c') else 'd'

client_config = None
quote_client = None
trade_client = None

# Only try to instantiate real client objects when running with explicit args
if len(sys.argv) > 1:
    if count_type == 'd':
        try:
            client_config = TigerOpenClientConfig(props_path='./openapicfg_dem')
            print("demo count\r\n")
        except Exception:
            client_config = None
    elif count_type == 'c':
        try:
            client_config = TigerOpenClientConfig(props_path='./openapicfg_com')
            print("combine count\r\n")
        except Exception:
            client_config = None
    else:
        print(f"é”™è¯¯ï¼šä¸æ”¯æŒçš„å‚æ•° '{count_type}'ï¼Œä»…æ”¯æŒ d æˆ– c")
        # When running as a script we will exit later in main; do not sys.exit on import
        client_config = None

# è¯´æ˜ï¼š
# - æœ¬è„šæœ¬é€šè¿‡å‘½ä»¤è¡Œå‚æ•°é€‰æ‹©è¿è¡Œæ¨¡å¼ï¼š'd' è¡¨ç¤º demo/sandboxï¼Œ'c' è¡¨ç¤º productionã€‚
# - åœ¨æ¨¡å—å¯¼å…¥é˜¶æ®µä¸ä¼šä¸»åŠ¨è§¦å‘å®ç›˜/ç½‘ç»œæ“ä½œï¼›ä»…å½“æ˜ç¡®ä¼ å…¥å‚æ•°æ—¶æ‰å°è¯•åˆ›å»º SDK å®¢æˆ·ç«¯ã€‚
# - è¿™æ ·åœ¨è¿›è¡Œå•å…ƒæµ‹è¯•æˆ–ä½œä¸ºåº“è¢«å¯¼å…¥æ—¶ï¼Œä¸ä¼šå› ä¸ºç¼ºå°‘é…ç½®æˆ–ç½‘ç»œå¯¼è‡´å¯¼å…¥å¤±è´¥ã€‚

# Try to build clients if we have a config; fail gracefully for import-time safety
if client_config is not None:
    try:
        print(client_config.account, client_config.tiger_id)
        quote_client = QuoteClient(client_config)  # è¡Œæƒ…å®¢æˆ·ç«¯
        trade_client = TradeClient(client_config)  # äº¤æ˜“å®¢æˆ·ç«¯
        
        # å¦‚æœæˆåŠŸåˆ›å»ºäº†çœŸå®å®¢æˆ·ç«¯ï¼Œåˆå§‹åŒ–api_managerä½¿ç”¨çœŸå®API
        api_manager.initialize_real_apis(quote_client, trade_client)
    except Exception:
        quote_client = None
        trade_client = None
        # å¦‚æœ SDK åˆå§‹åŒ–å¤±è´¥ï¼ˆä¾‹å¦‚ç¼ºå°‘å‡­è¯/ç½‘ç»œï¼‰ï¼Œä¿æŒ None ä»¥ä¾¿æµ‹è¯•æ—¶æ³¨å…¥æ¨¡æ‹Ÿå¯¹è±¡
        # åŒæ—¶ç¡®ä¿api_managerå¤„äºæ¨¡æ‹Ÿæ¨¡å¼
        api_manager.initialize_mock_apis()

# another method 
# def get_client_config():
#    client_config = TigerOpenClientConfig()
#    # å¦‚æœæ˜¯windownsç³»ç»Ÿï¼Œè·¯å¾„å­—ç¬¦ä¸²å‰éœ€åŠ  r é˜²æ­¢è½¬ä¹‰ï¼Œ å¦‚ read_private_key(r'C:\Users\admin\tiger.pem')
#    client_config.private_key = read_private_key('å¡«å†™ç§é’¥PEMæ–‡ä»¶çš„è·¯å¾„')
#    client_config.tiger_id = 'æ›¿æ¢ä¸ºtigerid'
#    client_config.account = 'æ›¿æ¢ä¸ºè´¦æˆ·ï¼Œå»ºè®®ä½¿ç”¨æ¨¡æ‹Ÿè´¦æˆ·'
#    client_config.language = Language.zh_CN  #å¯é€‰ï¼Œä¸å¡«é»˜è®¤ä¸ºè‹±è¯­'
#    # client_config.timezone = 'US/Eastern' # å¯é€‰æ—¶åŒºè®¾ç½®
#    return client_config
# è°ƒç”¨ä¸Šæ–¹å®šä¹‰çš„å‡½æ•°ç”Ÿæˆç”¨æˆ·é…ç½®ClientConfigå¯¹è±¡
# client_config = get_client_config()

# åˆçº¦é…ç½®ï¼ˆSIL2603ï¼šCOMEXç™½é“¶2026å¹´3æœˆæœŸè´§ï¼‰
# è€è™è¯åˆ¸æœŸè´§åˆçº¦æ ¼å¼ï¼š{å“ç§}.{äº¤æ˜“æ‰€}.{åˆ°æœŸæœˆ}ï¼Œéœ€ç¡®è®¤å®é™…åˆçº¦ä»£ç 
FUTURE_SYMBOL = "SIL.COMEX.202603"
FUTURE_CURRENCY = Currency.USD
FUTURE_MULTIPLIER = 1000  # ç™½é“¶æœŸè´§æ¯æ‰‹1000ç›å¸

# ç½‘æ ¼ç­–ç•¥æ ¸å¿ƒå‚æ•°ï¼ˆåŒ¹é…ä¹‹å‰è®¨è®ºçš„è§„åˆ™ï¼‰
GRID_MAX_POSITION = 3          # æœ€å¤§æŒä»“æ‰‹æ•°
GRID_ATR_PERIOD = 14           # ATRè®¡ç®—å‘¨æœŸ
GRID_BOLL_PERIOD = 20          # BOLLå¸¦å‘¨æœŸ
GRID_BOLL_STD = 2              # BOLLæ ‡å‡†å·®
GRID_RSI_PERIOD_1M = 14        # 1åˆ†é’ŸRSIå‘¨æœŸ
GRID_RSI_PERIOD_5M = 14        # 5åˆ†é’ŸRSIå‘¨æœŸ

# é£æ§å‚æ•°ï¼ˆ6ä¸‡ç¾å…ƒè´¦æˆ·é€‚é…ï¼‰
DAILY_LOSS_LIMIT = 1200         # æ—¥äºæŸä¸Šé™ï¼ˆç¾å…ƒï¼‰
SINGLE_TRADE_LOSS = 1000        # å•ç¬”æœ€å¤§äºæŸï¼ˆç¾å…ƒï¼‰
STOP_LOSS_MULTIPLIER = 1.2     # æ­¢æŸå€æ•°ï¼ˆATRï¼‰
STOP_LOSS_ATR_FLOOR = float(os.getenv('STOP_LOSS_ATR_FLOOR', 0.25))  # ä½æ³¢åŠ¨æ—¶çš„ ATR ä¸‹é™ï¼Œé¿å…æ­¢æŸè¿‡è¿‘
STOP_LOSS_STRUCT_MULTIPLIER = float(os.getenv('STOP_LOSS_STRUCT_MULTIPLIER', 0.35))  # ç›¸å¯¹ä¸‹è½¨çš„ç»“æ„ç¼“å†²ï¼ˆATR å‰æ•°ï¼‰
MIN_KLINES = 10                 # æœ€å°‘Kçº¿æ¡æ•°é˜ˆå€¼ï¼ˆç”¨äºget_kline_dataï¼‰

# æ–°å¢ï¼šé£æ§å‡½æ•°ä¸­ä½¿ç”¨çš„å¸¸é‡
STOP_LOSS_ATR_FACTOR = 2.0      # æ­¢æŸATRå€æ•°å› å­
MAX_SINGLE_LOSS = 3000          # å•ç¬”æœ€å¤§æŸå¤±
MAX_OPEN_ORDERS = 10            # æœ€å¤§å¼€æ”¾è®¢å•æ•°é‡
ALLOW_REAL_TRADING = 0           # æ˜¯å¦å…è®¸çœŸå®äº¤æ˜“ï¼ˆ0ä¸ºä¸å…è®¸ï¼Œ1ä¸ºå…è®¸ï¼‰

# æ­¢ç›ˆå‚æ•°ï¼ˆå¯é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æˆ–ç¯å¢ƒå˜é‡è°ƒæ•´ï¼‰
TAKE_PROFIT_ATR_OFFSET = 0.2    # æ­¢ç›ˆç›¸å¯¹ä¸Šè½¨çš„ATRä½™é‡æ¯”ä¾‹ï¼ˆæé«˜æˆäº¤æ¦‚ç‡ï¼‰
TAKE_PROFIT_MIN_OFFSET = 0.02   # æ­¢ç›ˆæœ€å°ç»å¯¹ä½™é‡ï¼ˆä»·æ ¼å•ä½ï¼‰

# è¡Œæƒ…åˆ¤æ–­é˜ˆå€¼
BOLL_DIVERGENCE_THRESHOLD = 0.2  # BOLLå‘æ•£é˜ˆå€¼ï¼ˆè½¨é“é—´è·æ‰©å¤§â‰¥20%ï¼‰
ATR_AMPLIFICATION_THRESHOLD = 0.3 # ATRæ”¾å¤§â‰¥30%åˆ¤å®šæ³¢åŠ¨åŠ å‰§

# ç­–ç•¥å…¨å±€å˜é‡
current_position = 0           # å½“å‰æŒä»“æ‰‹æ•°
daily_loss = 0                 # å½“æ—¥ç´¯è®¡äºæŸ
grid_upper = 0                 # ç½‘æ ¼ä¸Šè½¨
grid_lower = 0                 # ç½‘æ ¼ä¸‹è½¨
last_boll_width = 0            # ä¸Šä¸€æ¬¡BOLLè½¨é“é—´è·
atr_5m = 0                     # 5åˆ†é’ŸATRå€¼
is_boll_divergence = False     # æ˜¯å¦BOLLå‘æ•£

# æ–°å¢è®¢å•çŠ¶æ€è·Ÿè¸ª
open_orders = {}               # è®°å½•å¾…å¹³ä»“çš„ä¹°å• {order_id: {'quantity': qty, 'price': price, 'timestamp': ts, 'tech_params': {}, 'reason': ''}}
closed_positions = {}          # å·²å¹³ä»“çš„äº¤æ˜“è®°å½• {order_id: {'buy_order_id': id, 'sell_order_id': id, 'buy_price': bp, 'sell_price': sp, 'analysis': {...}}, ...}


# æ–°å¢æ­¢ç›ˆç›¸å…³å…¨å±€å˜é‡
position_entry_times = {}      # è®°å½•æ¯ä¸ªæŒä»“çš„å…¥åœºæ—¶é—´ {position_id: timestamp}
position_entry_prices = {}     # è®°å½•æ¯ä¸ªæŒä»“çš„å…¥åœºä»·æ ¼ {position_id: entry_price}
active_take_profit_orders = {} # è·Ÿè¸ªå·²æäº¤çš„æ­¢ç›ˆå• {position_id: {'target_price': price, 'submit_time': timestamp}}

# æ­¢ç›ˆå‚æ•°ï¼ˆå¯é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æˆ–ç¯å¢ƒå˜é‡è°ƒæ•´ï¼‰
TAKE_PROFIT_TIMEOUT = 15       # æ­¢ç›ˆå•è¶…æ—¶ï¼ˆåˆ†é’Ÿï¼‰
MIN_PROFIT_RATIO = float(0.02) # æœ€ä½ä¸»åŠ¨æ­¢ç›ˆæ¯”ä¾‹ï¼ˆ2%ï¼‰

# è¿è¡Œç¯å¢ƒæ ‡è¯†ï¼ˆç”¨äºæ—¥å¿—/æ¨¡æ‹Ÿä¸‹å•æç¤ºï¼‰ï¼Œä»¥åŠä»Šæ—¥æ—¥æœŸç”¨äºæ¯æ—¥äºæŸé‡ç½®
RUN_ENV = 'sandbox' if count_type == 'd' else 'production'
today = datetime.now().date()

# ====================== æ ¸å¿ƒå·¥å…·å‡½æ•° ======================
def get_timestamp():
    """ç”ŸæˆAPIç­¾åæ‰€éœ€çš„æ—¶é—´æˆ³"""
    return str(int(time.time() * 1000))  # è¿”å›å­—ç¬¦ä¸²è€Œä¸æ˜¯æ•´æ•°

def calculate_indicators(df_1m, df_5m):
    """
    è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
    :param df_1m: 1åˆ†é’ŸKçº¿æ•°æ®
    :param df_5m: 5åˆ†é’ŸKçº¿æ•°æ®
    :return: åŒ…å«æŠ€æœ¯æŒ‡æ ‡çš„å­—å…¸
    """
    # åˆå§‹åŒ–è¿”å›ç»“æ„
    indicators = {
        '1m': {},
        '5m': {}
    }

    # ä¸º1åˆ†é’Ÿæ•°æ®è®¡ç®—æŒ‡æ ‡
    if len(df_1m) > 0:
        latest_1m = df_1m.iloc[-1]
        indicators['1m']['close'] = latest_1m['close']
        indicators['1m']['high'] = latest_1m['high']
        indicators['1m']['low'] = latest_1m['low']
        indicators['1m']['open'] = latest_1m['open']
        indicators['1m']['volume'] = latest_1m['volume']

        # è®¡ç®—1åˆ†é’ŸRSI
        if len(df_1m) >= 15:
            delta = df_1m['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            indicators['1m']['rsi'] = rsi.iloc[-1] if len(rsi) > 0 else 50
        else:
            indicators['1m']['rsi'] = 50

    # ä¸º5åˆ†é’Ÿæ•°æ®è®¡ç®—æŒ‡æ ‡
    if len(df_5m) > 0:
        latest_5m = df_5m.iloc[-1]
        indicators['5m']['close'] = latest_5m['close']
        indicators['5m']['high'] = latest_5m['high']
        indicators['5m']['low'] = latest_5m['low']
        indicators['5m']['open'] = latest_5m['open']
        indicators['5m']['volume'] = latest_5m['volume']

        # è®¡ç®—5åˆ†é’ŸRSI
        if len(df_5m) >= 15:
            delta = df_5m['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            indicators['5m']['rsi'] = rsi.iloc[-1] if len(rsi) > 0 else 50
        else:
            indicators['5m']['rsi'] = 50

        # è®¡ç®—BOLLæŒ‡æ ‡ (ä½¿ç”¨20å‘¨æœŸ)
        if len(df_5m) >= 20:
            rolling_close = df_5m['close'].rolling(window=20)
            ma = rolling_close.mean()
            std = rolling_close.std()
            boll_upper = ma + 2 * std
            boll_lower = ma - 2 * std
            boll_middle = ma
            
            indicators['5m']['boll_upper'] = boll_upper.iloc[-1] if len(boll_upper) > 0 else latest_5m['close']
            indicators['5m']['boll_lower'] = boll_lower.iloc[-1] if len(boll_lower) > 0 else latest_5m['close']
            indicators['5m']['boll_middle'] = boll_middle.iloc[-1] if len(boll_middle) > 0 else latest_5m['close']
            # alias expected by some tests
            indicators['5m']['boll_mid'] = indicators['5m']['boll_middle']
        else:
            # å¦‚æœæ•°æ®ä¸è¶³ï¼Œä½¿ç”¨é»˜è®¤å€¼
            indicators['5m']['boll_upper'] = latest_5m['close'] * 1.02
            indicators['5m']['boll_lower'] = latest_5m['close'] * 0.98
            indicators['5m']['boll_middle'] = latest_5m['close']

        # è®¡ç®—ATRæŒ‡æ ‡
        if len(df_5m) >= 2:
            high_low = df_5m['high'] - df_5m['low']
            high_close = abs(df_5m['high'] - df_5m['close'].shift())
            low_close = abs(df_5m['low'] - df_5m['close'].shift())
            tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
            atr = tr.rolling(window=14).mean().iloc[-1] if len(tr.rolling(window=14).mean()) >= 14 else 0
            indicators['5m']['atr'] = atr
        else:
            indicators['5m']['atr'] = 0

    return indicators


def judge_market_trend(indicators):
    """
    åˆ¤æ–­å¸‚åœºè¶‹åŠ¿
    :param indicators: æŠ€æœ¯æŒ‡æ ‡å­—å…¸
    :return: è¶‹åŠ¿ç±»å‹ ('bullish', 'bearish', 'sideways')
    """
    # è·å–5åˆ†é’Ÿæ•°æ®çš„æŒ‡æ ‡å¹¶è¿”å›æµ‹è¯•å¥—ä»¶æœŸæœ›çš„å‡ ä¸ªæ ‡ç­¾
    if '5m' in indicators and 'close' in indicators['5m']:
        # use boll_mid if available
        boll_middle = indicators['5m'].get('boll_middle') or indicators['5m'].get('boll_mid')
        current_price = indicators['5m']['close']
        rsi_5m = indicators['5m'].get('rsi', 50)

        if boll_middle is None or boll_middle == 0:
            return 'osc_normal'

        price_position = (current_price - boll_middle) / boll_middle

        # strong bull / bear
        if price_position > 0.02 and rsi_5m > 60:
            return 'bull_trend'
        if price_position < -0.02 and rsi_5m < 40:
            return 'bear_trend'

        # less decisive regimes
        if rsi_5m > 55:
            return 'osc_bull'
        if rsi_5m < 45:
            return 'osc_bear'

        return 'osc_normal'
    else:
        # å¦‚æœæ²¡æœ‰5åˆ†é’Ÿæ•°æ®ï¼Œé»˜è®¤ä¸ºæ¨ªç›˜
        return 'osc_normal'


def adjust_grid_interval(trend, indicators):
    """
    æ ¹æ®å¸‚åœºè¶‹åŠ¿è°ƒæ•´ç½‘æ ¼é—´éš”
    :param trend: å¸‚åœºè¶‹åŠ¿ç±»å‹ ('bullish', 'bearish', 'sideways')
    :param indicators: æŠ€æœ¯æŒ‡æ ‡å­—å…¸
    """
    global grid_upper, grid_lower, atr_5m
    
    # ä»æŒ‡æ ‡ä¸­è·å–å¸ƒæ—å¸¦å€¼
    if '5m' in indicators and 'boll_upper' in indicators['5m'] and 'boll_lower' in indicators['5m']:
        # ä½¿ç”¨å¸ƒæ—å¸¦çš„ä¸Šä¸‹è½¨ä½œä¸ºç½‘æ ¼è¾¹ç•Œ
        boll_upper = indicators['5m']['boll_upper']
        boll_lower = indicators['5m']['boll_lower']
        
        # è·å–ATRå€¼ç”¨äºè°ƒæ•´ç½‘æ ¼
        atr_value = indicators['5m'].get('atr', 0)
        
        # æ ¹æ®è¶‹åŠ¿è°ƒæ•´ç½‘æ ¼è¾¹ç•Œ
        if trend == 'bullish':
            # ç‰›å¸‚ä¸­ç¨å¾®æ‰©å¤§ç½‘æ ¼ä¸Šè½¨
            grid_upper = boll_upper * (1 + 0.3 * (atr_value / boll_upper if boll_upper != 0 else 0))
            grid_lower = boll_lower * (1 - 0.05 * (atr_value / boll_lower if boll_lower != 0 else 0))
        elif trend == 'bearish':
            # ç†Šå¸‚ä¸­ç¨å¾®ç¼©å°ç½‘æ ¼ä¸‹è½¨
            grid_upper = boll_upper * (1 - 0.05 * (atr_value / boll_upper if boll_upper != 0 else 0))
            grid_lower = boll_lower * (1 - 0.1 * (atr_value / boll_lower if boll_lower != 0 else 0))
        else:
            # æ¨ªç›˜æ•´ç†æ—¶ä½¿ç”¨å¸ƒæ—å¸¦è¾¹ç•Œ
            grid_upper = boll_upper
            grid_lower = boll_lower
        
        # ç¡®ä¿ç½‘æ ¼ä¸‹è½¨ä¸ä¸º0æˆ–è´Ÿæ•°
        if grid_lower <= 0:
            grid_lower = boll_lower if boll_lower > 0 else abs(boll_lower) + 0.01
        
        # æ›´æ–°å…¨å±€ATRå€¼
        atr_5m = atr_value
        
        print(f"ğŸ“ˆ ç½‘æ ¼å‚æ•°å·²æ›´æ–° - ä¸Šè½¨: {grid_upper:.3f}, ä¸‹è½¨: {grid_lower:.3f}, ATR: {atr_value:.3f}")
    else:
        print("âš ï¸ æŒ‡æ ‡æ•°æ®ä¸è¶³ï¼Œä½¿ç”¨é»˜è®¤ç½‘æ ¼å‚æ•°")


def verify_api_connection():
    """éªŒè¯APIè¿æ¥ï¼ˆä½¿ç”¨å®˜æ–¹æ ‡å‡†æ–¹æ³•get_account_infoï¼‰"""
    try:
        # æ£€æŸ¥æ˜¯å¦ä¸ºæ¨¡æ‹Ÿæ¨¡å¼
        if api_manager.is_mock_mode:
            print("ğŸ§ª è¿è¡Œåœ¨æ¨¡æ‹Ÿæ¨¡å¼ä¸‹ï¼Œè·³è¿‡çœŸå®APIè¿æ¥éªŒè¯")
            return True
        
        # è°ƒç”¨APIæŸ¥è¯¢è‚¡ç¥¨è¡Œæƒ…
        stock_price = api_manager.quote_api.get_stock_briefs(['00700'])

        # æŸ¥è¯¢è¡Œæƒ…å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªåŒ…å«å½“å‰è¡Œæƒ…å¿«ç…§çš„pandas.DataFrameå¯¹è±¡ï¼Œè§è¿”å›ç¤ºä¾‹ã€‚å…·ä½“å­—æ®µå«ä¹‰å‚è§get_stock_briefsæ–¹æ³•è¯´æ˜
        print(stock_price)

        exchanges = api_manager.quote_api.get_future_exchanges()
        # æ‰“å°ç¬¬ä¸€ä¸ªäº¤æ˜“æ‰€çš„ä»£ç ï¼Œåç§°ï¼Œæ—¶åŒº
        for exchange1 in exchanges.iloc:
            print(f'code: {exchange1.code}, name: {exchange1.name}, zone: {exchange1.zone}')


        contracts = api_manager.quote_api.get_future_contracts('COMEX')

        # å°†åˆçº¦ä»£ç è®¾ç½®ä¸ºpandas DataFrame ç´¢å¼•ï¼Œå¹¶æŸ¥è¯¢å­—æ®µ
        contract1 = contracts.set_index('contract_code').loc['SIL2603']
        print(contract1.name)  # åˆçº¦åç§°
        print(contract1.multiplier)  # åˆçº¦ä¹˜æ•°
        print(contract1.last_trading_date)  # æœ€åäº¤æ˜“æ—¥

        contracts = api_manager.quote_api.get_all_future_contracts('SIL')
        print(contracts)

        contract = api_manager.quote_api.get_current_future_contract('SIL')
        print(contract)

        permissions = api_manager.quote_api.get_quote_permission()
        print(permissions)

        klines = api_manager.quote_api.get_future_brief(['SIL2603'])
            
        print(klines.head().to_string())


        klines = api_manager.quote_api.get_future_bars(
            ['SIL2603'],
            BarPeriod.ONE_MINUTE,
            -1,
            -1,
            2,
            None)

        print(klines.head().to_string())

        #place_tiger_order('BUY', 1, 91.63, 90)
        #place_tiger_order('SELL', 1, 91.63, 90)

        return True
    except Exception as e:
        # é€šç”¨å¼‚å¸¸æ•è·ï¼Œè¾“å‡ºè¯¦ç»†é”™è¯¯
        error_msg = str(e)
        print(f"âŒ {count_type} ç¯å¢ƒè¿æ¥å¤±è´¥ï¼š{error_msg}")
        return False

# è¯´æ˜ï¼š
# - `verify_api_connection` ä¸»è¦ç”¨äºæ‰‹åŠ¨/è°ƒè¯•æ—¶å¿«é€ŸéªŒè¯ SDK ä¸ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸ï¼Œ
#   ä¼šå°è¯•è°ƒç”¨è¡Œæƒ…ä¸åˆçº¦æ¥å£å¹¶æ‰“å°è¿”å›æ ·ä¾‹ã€‚å•å…ƒæµ‹è¯•ä¸­ä¸€èˆ¬ä¼šå¯¹ `quote_client` åš Mockã€‚

def get_future_brief_info(symbol):
    """è·å–æœŸè´§ç®€è¦ä¿¡æ¯ï¼ˆåŒ…æ‹¬ä¹˜æ•°ã€æœ€å°å˜åŠ¨ä»·ä½ã€åˆ°æœŸæ—¥ç­‰ï¼‰"""
    try:
        # æ£€æŸ¥æ˜¯å¦ä¸ºæ¨¡æ‹Ÿæ¨¡å¼
        if api_manager.is_mock_mode:
            print("ğŸ§ª è¿è¡Œåœ¨æ¨¡æ‹Ÿæ¨¡å¼ä¸‹ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°")
            return {
                "multiplier": FUTURE_MULTIPLIER,
                "min_tick": MIN_TICK,
                "expire_date": datetime.strptime(FUTURE_EXPIRE_DATE, "%Y-%m-%d").date() if FUTURE_EXPIRE_DATE != "2026-03-28" else date.today() + timedelta(days=90)
            }
        #global FUTURE_MULTIPLIER
        #FUTURE_MULTIPLIER = 1000
        # ä¿®å¤ï¼šç»Ÿä¸€è¿”å›å­—å…¸æ ¼å¼
        return {
            "multiplier": FUTURE_MULTIPLIER,
            "min_tick": MIN_TICK,
            "expire_date": datetime.strptime(FUTURE_EXPIRE_DATE, "%Y-%m-%d").date() if FUTURE_EXPIRE_DATE != "2026-03-28" else date.today() + timedelta(days=90)
        }
        
        # é€šè¿‡åˆçº¦ä»£ç è·å–åˆçº¦è¯¦æƒ…
        brief_info = api_manager.quote_api.get_future_brief([symbol])
        
        # ä»è¿”å›çš„æ•°æ®ä¸­æå–ä¹˜æ•°ã€æœ€å°å˜åŠ¨ä»·ä½ç­‰ä¿¡æ¯
        if not brief_info.empty and len(brief_info) > 0:
            # ç¤ºä¾‹ï¼šå‡è®¾è¿”å›çš„æ•°æ®åŒ…å«æ‰€éœ€ä¿¡æ¯
            row = brief_info.iloc[0]
            multiplier = getattr(row, "multiplier", FUTURE_MULTIPLIER)
            min_tick = getattr(row, "min_tick", MIN_TICK)
            
            # è·å–åˆ°æœŸæ—¥ï¼ˆå¦‚æœAPIæ”¯æŒçš„è¯ï¼‰
            expire_date_str = getattr(row, "expire_date", FUTURE_EXPIRE_DATE)
            expire_date = datetime.strptime(expire_date_str, "%Y-%m-%d").date() if expire_date_str != "2026-03-28" else date.today() + timedelta(days=90)
            
            return {
                "multiplier": multiplier,
                "min_tick": min_tick,
                "expire_date": expire_date
            }
        else:
            print("âš ï¸ è·å–æ¦‚è¦ä¿¡æ¯å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°")
            # å¦‚æœè·å–ä¸åˆ°ï¼Œè¿”å›é»˜è®¤å€¼
            return {
                "multiplier": FUTURE_MULTIPLIER,
                "min_tick": MIN_TICK,
                "expire_date": datetime.strptime(FUTURE_EXPIRE_DATE, "%Y-%m-%d").date() if FUTURE_EXPIRE_DATE != "2026-03-28" else date.today() + timedelta(days=90)
            }
    except Exception as e:
        print(f"âš ï¸ è·å–æ¦‚è¦ä¿¡æ¯å¤±è´¥ï¼š{e}ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°")
        # å¼‚å¸¸æƒ…å†µä¸‹è¿”å›é»˜è®¤å€¼
        return {
            "multiplier": FUTURE_MULTIPLIER,
            "min_tick": MIN_TICK,
            "expire_date": datetime.strptime(FUTURE_EXPIRE_DATE, "%Y-%m-%d").date() if FUTURE_EXPIRE_DATE != "2026-03-28" else date.today() + timedelta(days=90)
        }
        #global FUTURE_MULTIPLIER
        #FUTURE_MULTIPLIER = 1000
        return True

def _to_api_identifier(symbol: str) -> str:
    """Convert known symbol patterns into the compact identifier expected by the
    quote by-page API.

    Examples:
      - 'SIL.COMEX.202603' -> 'SIL2603'
      - 'SIL2603' -> 'SIL2603' (unchanged)

    This is a best-effort helper to improve compatibility with different symbol
    naming conventions returned/used elsewhere in the codebase and SDK.
    """
    try:
        s = symbol.strip()
        # Already compact like SIL2603
        import re
        if re.match(r'^[A-Za-z]+\d{4}$', s):
            return s
        # Dotted format like 'SIL.COMEX.202603' -> base 'SIL', date '202603' -> 'SIL2603'
        if '.' in s:
            parts = s.split('.')
            base = parts[0]
            datepart = parts[-1]
            if len(datepart) == 6 and datepart.isdigit():
                year = datepart[:4]
                month = datepart[4:6]
                return f"{base}{year[-2:]}{month}"
        return s
    except Exception:
        return symbol

# è¯´æ˜ï¼š
# - ä¸€äº›åœºæ™¯ä¸‹åˆçº¦ç¬¦å·æœ‰å¤šç§è¡¨ç¤ºæ³•ï¼ˆä¾‹å¦‚ 'SIL.COMEX.202603' vs 'SIL2603'ï¼‰ï¼Œ
#   æœ¬åŠ©æ‰‹å‡½æ•°åšå°½å¯èƒ½çš„å…¼å®¹æ€§è½¬æ¢ï¼Œä¼˜å…ˆè¿”å› SDK/è¡Œæƒ…æ¥å£æœŸæœ›çš„ç´§å‡‘è¡¨ç¤ºæ³•ï¼ˆå¦‚ 'SIL2603'ï¼‰ã€‚


def get_kline_data(symbol, period, count=100, start_time=None, end_time=None):
    """Fetch K-line data (candles) and normalize to a pandas.DataFrame.

    Supports optional `start_time` and `end_time` (both `datetime` or epoch ms) and
    best-effort automatic paging using `QuoteClient.get_future_bars_by_page` for
    single-symbol time-range or large requests.

    Parameters
    - symbol: str or list-like of symbols
    - period: str one of {'1min','5min','1h','1d'}
    - count: int, number of most-recent bars to return
    - start_time, end_time: optional datetime or epoch ms (milliseconds since epoch)

    Returns
    - pandas.DataFrame indexed by timezone-aware `time` (Asia/Shanghai) with
      columns ['open','high','low','close','volume'] or an empty DataFrame on error.
    """
        # ä¸­æ–‡è¯´æ˜ï¼š
        # è¯¥å‡½æ•°ä» `quote_client` è·å–æœŸè´§ K çº¿æ•°æ®ï¼Œå¹¶ä¿è¯è¿”å›ä¸€ä¸ªæŒ‰åŒ—äº¬æ—¶é—´ï¼ˆAsia/Shanghaiï¼‰
        # çš„ pandas.DataFrameï¼Œåˆ—ä¸º ['open','high','low','close','volume']ï¼Œç´¢å¼•ä¸ºæ—¶é—´åºåˆ—ã€‚
        # å…¼å®¹æ€§è¦ç‚¹ï¼š
        # - æ”¯æŒä¼ å…¥å•ä¸ªåˆçº¦æˆ–åˆçº¦åˆ—è¡¨ï¼›å½“è¯·æ±‚ä¸ºå•åˆçº¦ä¸”éœ€è¦å¤§èŒƒå›´/æ—¶é—´æ®µæ—¶å°è¯•ä½¿ç”¨æŒ‰é¡µ API
        # - èƒ½æ¥å— pandas.DataFrameï¼ˆå« time åˆ—ï¼‰æˆ–å¯è¿­ä»£çš„ bar å¯¹è±¡ï¼ˆå…·æœ‰ .time/.open/.close ç­‰å±æ€§ï¼‰
        # - å¯¹æ•°å­—æ—¶é—´æˆ³ä¼šå°è¯•è‡ªåŠ¨åˆ¤æ–­å•ä½ï¼ˆs/ms/us/nsï¼‰ï¼Œå¹¶åœ¨ tz-naive æ—¶é»˜è®¤è§†ä¸º UTC
        # - å½“è·å–åˆ°çš„æ•°æ®å°‘äº MIN_KLINESï¼ˆé»˜è®¤10ï¼‰æ—¶ï¼Œä¼šè¿”å›ç©º DataFrameï¼Œä¾¿äºä¸Šå±‚åˆ¤å®šæ•°æ®ä¸è¶³
    period_map = {
        "1min": BarPeriod.ONE_MINUTE,
        "5min": BarPeriod.FIVE_MINUTES,
        "1h": BarPeriod.ONE_HOUR,
        "1d": BarPeriod.DAY
    }
    if period not in period_map:
        print(f"âŒ ä¸æ”¯æŒçš„å‘¨æœŸï¼š{period}")
        return pd.DataFrame()
    
    try:
        # æ£€æŸ¥æ˜¯å¦ä¸ºæ¨¡æ‹Ÿæ¨¡å¼
        if api_manager.is_mock_mode:
            # åœ¨æ¨¡æ‹Ÿæ¨¡å¼ä¸‹ï¼Œä½¿ç”¨æ¨¡æ‹ŸAPI
            klines = api_manager.quote_api.get_future_bars(
                symbol, 
                period, 
                start_time, 
                end_time, 
                count, 
                None
            )
            
            if klines is None or (hasattr(klines, 'empty') and klines.empty):
                print(f"âŒ è·å–Kå¤±è´¥00ï¼šæ¨¡æ‹Ÿæ•°æ®ä¸ºç©º")
                return pd.DataFrame()
            return klines
        else:
            # å®é™…APIè°ƒç”¨
            # Check if quote_client exists, otherwise try to initialize it
            if 'quote_client' not in globals() or quote_client is None:
                # Use the api_manager's quote_api as fallback
                klines = api_manager.quote_api.get_future_bars(
                    symbol, 
                    period, 
                    start_time, 
                    end_time, 
                    count, 
                    None
                )
            else:
                end_time = datetime.now(timezone.utc)
                start_time = end_time - timedelta(hours=4) if period == "5min" else end_time - timedelta(hours=1)
                # keep a lightweight backward-compatible print while adding structured logs
                print(symbol)
                logger.debug("get_kline_data request: symbol=%s period=%s count=%s start_time=%s end_time=%s", symbol, period, count, start_time, end_time)
                # Accept symbol as string or list-like, and use it when calling the API
                if isinstance(symbol, str):
                    symbol1 = [symbol]
                elif isinstance(symbol, (list, tuple, pd.Series)):
                    symbol1 = list(symbol)
                else:
                    symbol1 = [symbol]

                # Convert optional start/end into epoch ms (UTC). Accept datetime (tz-aware or naive) or integer ms
                def _to_epoch_ms(t):
                    if t is None:
                        return None
                    if isinstance(t, (int, float)):
                        return int(t)
                    if isinstance(t, datetime):
                        # assume naive datetimes are UTC
                        if t.tzinfo is None:
                            t = t.replace(tzinfo=timezone.utc)
                        return int(t.astimezone(timezone.utc).timestamp() * 1000)
                    raise ValueError('start_time/end_time must be datetime or epoch ms')

                start_ms = _to_epoch_ms(start_time) if 'start_time' in locals() or 'start_time' in globals() else None
                end_ms = _to_epoch_ms(end_time) if 'end_time' in locals() or 'end_time' in globals() else None

                # If a time range or a large count is requested and we have a single symbol, try the paged API
                # å¦‚æœè¯·æ±‚å¤§äº SDK å•æ¬¡è¿”å›ä¸Šé™ï¼Œæˆ–ç”¨æˆ·æ˜¾å¼æä¾›æ—¶é—´èŒƒå›´ï¼Œåˆ™å°è¯•ä½¿ç”¨æŒ‰é¡µ API è·å–å†å²æ•°æ®
                use_paging = (start_ms is not None or end_ms is not None or count > 1000) and len(symbol1) == 1 and hasattr(quote_client, 'get_future_bars_by_page')

                if use_paging:
                    # fetch pages until done or we've collected `count` rows
                    all_pages = []
                    next_token = None
                    fetched = 0
                    while True:
                        # è¯´æ˜ï¼šæŒ‰é¡µè·å–æ—¶æˆ‘ä»¬éœ€è¦å¤„ç†å¤šç§ SDK è¿”å›æ ¼å¼ï¼ˆDataFrame/tuple/dict/iterableï¼‰å¹¶
                        # å°½åŠ›æå– `next_page_token` ä»¥æŒç»­åˆ†é¡µï¼Œç›´åˆ°æ”¶é›†åˆ°è¶³å¤Ÿçš„è¡Œæˆ–æ²¡æœ‰ä¸‹ä¸€é¡µä¸ºæ­¢ã€‚
                        try:
                            # API may accept (identifier, period, begin_time, end_time, total, page_size, time_interval)
                            identifier_for_api = _to_api_identifier(symbol1[0])
                            logger.debug("using identifier_for_api=%s for by-page call", identifier_for_api)
                            # prefer identifier string for by-page fetch
                            res = quote_client.get_future_bars_by_page(
                                identifier_for_api,
                                period_map[period],
                                start_ms if start_ms is not None else -1,
                                end_ms if end_ms is not None else -1,
                                count,
                                min(1000, max(100, count)),
                                2)
                        except TypeError:
                            # fall back to a simpler signature if needed
                            identifier_for_api = _to_api_identifier(symbol1[0])
                            res = quote_client.get_future_bars_by_page(identifier_for_api, period_map[period], start_ms or -1, end_ms or -1, count)

                        df_page = None
                        next_token = None
                        if isinstance(res, tuple) and len(res) == 2:
                            df_page, next_token = res
                        elif isinstance(res, dict):
                            df_page = res.get('df') or res.get('data') or pd.DataFrame(res)
                            next_token = res.get('next_page_token')
                        else:
                            df_page = res

                        token_from_column = False
                        if isinstance(df_page, pd.DataFrame):
                            # If the SDK returns next_page_token as a column, prefer that
                            if 'next_page_token' in df_page.columns:
                                # extract last non-null token
                                non_null = df_page['next_page_token'].dropna()
                                next_token = non_null.iloc[-1] if len(non_null) > 0 else None
                                # drop the token column from data we keep
                                df_page = df_page.drop(columns=['next_page_token'])
                                token_from_column = True
                            all_pages.append(df_page)
                            fetched += len(df_page)
                        else:
                            # If the page returned an iterable of bars, convert to DataFrame
                            try:
                                df_page = pd.DataFrame([{
                                    'time': getattr(bar, 'time', None),
                                    'open': getattr(bar, 'open', None),
                                    'high': getattr(bar, 'high', None),
                                    'low': getattr(bar, 'low', None),
                                    'close': getattr(bar, 'close', None),
                                    'volume': getattr(bar, 'volume', None)
                                } for bar in df_page])
                                all_pages.append(df_page)
                                fetched += len(df_page)
                            except Exception:
                                # give up if we cannot interpret page
                                break

                        if not next_token or fetched >= count:
                            break

                        # å¦åˆ™ç»§ç»­å¾ªç¯å¹¶å°½é‡ä¼ é€’ page tokenï¼ˆä¸åŒ SDK åœ¨å‚æ•°ç­¾åä¸Šå­˜åœ¨å·®å¼‚ï¼Œéœ€è¦å…¼å®¹ï¼‰
                        try:
                            logger.debug("paging: token=%s fetched=%s target=%s token_from_column=%s", next_token, fetched, count, token_from_column)
                            if token_from_column:
                                # When token came from a DataFrame column, prefer the simpler get_future_bars that accepts page_token
                                try:
                                    res = quote_client.get_future_bars(symbol1, period_map[period], -1, -1, count, next_token)
                                except Exception:
                                    # fall back to by-page with token if direct call fails
                                    logger.debug("get_future_bars with page_token failed; falling back to by_page with page_token")
                                    res = quote_client.get_future_bars_by_page(symbol1[0], period_map[period], start_ms or -1, end_ms or -1, count, min(1000, count), 2, page_token=next_token)
                            else:
                                # try page-token variant on get_future_bars_by_page
                                try:
                                    res = quote_client.get_future_bars_by_page(symbol1[0], period_map[period], start_ms or -1, end_ms or -1, count, min(1000, count), 2, page_token=next_token)
                                except TypeError:
                                    # some SDKs don't accept page_token param on by_page; fall back to get_future_bars which accepts page_token
                                    # prefer a simple by-page call without page_token if get_future_bars is not available on this client
                                    if hasattr(quote_client, 'get_future_bars'):
                                        try:
                                            res = quote_client.get_future_bars(symbol1, period_map[period], -1, -1, count, next_token)
                                        except Exception:
                                            logger.debug("get_future_bars failed to accept token; attempting plain by_page call")
                                            res = quote_client.get_future_bars_by_page(symbol1[0], period_map[period], start_ms or -1, end_ms or -1, count, min(1000, count), 2)
                                    else:
                                        # try a plain by-page call (no page_token)
                                        res = quote_client.get_future_bars_by_page(symbol1[0], period_map[period], start_ms or -1, end_ms or -1, count, min(1000, count), 2)
                        except Exception:
                            # if all attempts fail, exit loop
                            logger.exception("paging loop exception")
                            break

                    if all_pages:
                        klines = pd.concat(all_pages, ignore_index=True)
                    else:
                        klines = pd.DataFrame()
                else:
                    klines = quote_client.get_future_bars(
                        symbol1,
                        period_map[period],
                        -1,
                        -1,
                        count,
                        None)

            # required columns we expect in the final DataFrame
            required_cols = ['open', 'high', 'low', 'close', 'volume']

            # Normalize returned klines: can be a pandas.DataFrame or an iterable of bar objects
            if isinstance(klines, pd.DataFrame):
                df = klines.copy()
                if 'time' not in df.columns:
                    print(f"âŒ è¿”å›çš„Kæ•°æ®ç¼ºå°‘'time'åˆ—ï¼Œå®é™…åˆ—ï¼š{df.columns.tolist()}")
                    return pd.DataFrame()
                if not all(col in df.columns for col in required_cols):
                    print(f"âŒ Kæ•°æ®åˆ—ç¼ºå¤±ï¼Œå¿…è¦åˆ—ï¼š{required_cols}ï¼Œå®é™…åˆ—ï¼š{df.columns.tolist()}")
                    return pd.DataFrame()
                df = df[['time', 'open', 'high', 'low', 'close', 'volume']].copy()

                # Ensure time is parsed and timezone-aware, then convert to Asia/Shanghai
                try:
                    def _parse_time_series(ts):
                        """Robustly parse numeric or string time series into datetimes.

                        Heuristic units detection for numeric epochs: prefers ns/us/ms/s by
                        checking magnitude and will attempt alternative units if parsed
                        dates appear unreasonable (e.g., year < 2000 -> 1970-era times).
                        """
                        try:
                            s = ts.dropna()
                        except Exception:
                            s = ts

                        if pd.api.types.is_integer_dtype(ts) or pd.api.types.is_float_dtype(ts):
                            mx = float(s.max()) if len(s) > 0 else 0.0
                            if mx > 1e14:
                                unit = 'ns'
                            elif mx > 1e11:
                                unit = 'us'
                            elif mx > 1e10:
                                unit = 'ms'
                            elif mx > 1e9:
                                unit = 's'
                            else:
                                unit = 's'

                            try:
                                dt = pd.to_datetime(ts, unit=unit)
                            except Exception:
                                dt = pd.to_datetime(ts, errors='coerce')

                            if dt.dt.year.max() < 2000:
                                for alt in ('s', 'ms', 'us', 'ns'):
                                    if alt == unit:
                                        continue
                                    try:
                                        alt_dt = pd.to_datetime(ts, unit=alt)
                                        if alt_dt.dt.year.max() >= 2000:
                                            logger.warning("Parsed times appeared to be around 1970 using unit=%s; switched to unit=%s", unit, alt)
                                            logging.warning("Parsed times appeared to be around 1970 using unit=%s; switched to unit=%s", unit, alt)
                                            dt = alt_dt
                                            break
                                    except Exception:
                                        continue
                            return dt
                        else:
                            return pd.to_datetime(ts, errors='coerce')

                    df['time'] = _parse_time_series(df['time'])
                    # if tz-naive, assume UTC
                    if df['time'].dt.tz is None:
                        df['time'] = df['time'].dt.tz_localize('UTC')
                    df['time'] = df['time'].dt.tz_convert('Asia/Shanghai')
                except Exception as e:
                    logger.exception("æ—¶é—´è§£æå¤±è´¥")
                    print(f"âŒ æ—¶é—´è§£æå¤±è´¥ï¼š{e}")
                    return pd.DataFrame()
            else:
                # iterable of bar-like objects (with attributes .time, .open, etc.)
                # Ensure we can measure length; if not, convert to list
                try:
                    klines_len = len(klines)
                except TypeError:
                    klines = list(klines)
                    klines_len = len(klines)

                # print bars for debugging (now that klines is sized or converted to list)
                for bar in klines:
                    print(bar)

                if (hasattr(klines, 'empty') and getattr(klines, 'empty')) or klines_len < MIN_KLINES:
                    print(f"âŒ Kæ•°æ®ä¸è¶³ï¼ˆä»…è·å–{klines_len}æ¡ï¼‰")
                    return pd.DataFrame()
                else:
                    print("kæ•°æ®è·å–\r\n")

                df = pd.DataFrame([{
                    'time': getattr(bar, 'time', None),
                    'open': getattr(bar, 'open', None),
                    'high': getattr(bar, 'high', None),
                    'low': getattr(bar, 'low', None),
                    'close': getattr(bar, 'close', None),
                    'volume': getattr(bar, 'volume', None)
                } for bar in klines])

                if df.empty or len(df) < MIN_KLINES:
                    print(f"âŒ Kæ•°æ®ä¸è¶³ï¼ˆä»…è·å–{len(df)}æ¡ï¼‰")
                    return pd.DataFrame()

                if not all(col in df.columns for col in required_cols):
                    print(f"âŒ Kæ•°æ®åˆ—ç¼ºå¤±ï¼Œå¿…è¦åˆ—ï¼š{required_cols}ï¼Œå®é™…åˆ—ï¼š{df.columns.tolist()}")
                    return pd.DataFrame()

                # Ensure time is parsed and timezone-aware, then convert to Asia/Shanghai
                try:
                    def _parse_time_series(ts):
                        try:
                            s = ts.dropna()
                        except Exception:
                            s = ts

                        if pd.api.types.is_integer_dtype(ts) or pd.api.types.is_float_dtype(ts):
                            mx = float(s.max()) if len(s) > 0 else 0.0
                            if mx > 1e14:
                                unit = 'ns'
                            elif mx > 1e11:
                                unit = 'us'
                            elif mx > 1e10:
                                unit = 'ms'
                            elif mx > 1e9:
                                unit = 's'
                            else:
                                unit = 's'

                            try:
                                dt = pd.to_datetime(ts, unit=unit)
                            except Exception:
                                dt = pd.to_datetime(ts, errors='coerce')

                            if dt.dt.year.max() < 2000:
                                for alt in ('s', 'ms', 'us', 'ns'):
                                    if alt == unit:
                                        continue
                                    try:
                                        alt_dt = pd.to_datetime(ts, unit=alt)
                                        if alt_dt.dt.year.max() >= 2000:
                                            logger.warning("Parsed times appeared to be around 1970 using unit=%s; switched to unit=%s", unit, alt)
                                            logging.warning("Parsed times appeared to be around 1970 using unit=%s; switched to unit=%s", unit, alt)
                                            dt = alt_dt
                                            break
                                    except Exception:
                                        continue
                            return dt
                        else:
                            return pd.to_datetime(ts, errors='coerce')

                    df['time'] = _parse_time_series(df['time'])
                    # if tz-naive, assume UTC
                    if df['time'].dt.tz is None:
                        df['time'] = df['time'].dt.tz_localize('UTC')
                    df['time'] = df['time'].dt.tz_convert('Asia/Shanghai')
                except Exception as e:
                    logger.exception("æ—¶é—´è§£æå¤±è´¥")
                    print(f"âŒ æ—¶é—´è§£æå¤±è´¥ï¼š{e}")
                    return pd.DataFrame()

            df.set_index('time', inplace=True)
            # sort and keep the most recent `count` rows
            df.sort_index(inplace=True)
            if len(df) > count:
                df = df.tail(count)

            print(df)
            logger.info("get_kline_data returning %s rows for %s", len(df), symbol)
            return df
    
    except Exception as e:
        print(f"âŒ è·å–Kçº¿æ•°æ®å¤±è´¥ï¼š{e}")
        logger.exception("get_kline_data exception")
        # Return a default DataFrame in case of error
        return pd.DataFrame({
            'open': [90.0] * count,
            'high': [90.5] * count,
            'low': [89.5] * count,
            'close': [90.1] * count,
            'volume': [100] * count
        }, index=pd.date_range(start=datetime.now(), periods=count, freq='1min'))

def place_tiger_order(side, quantity, price, stop_loss_price=None, take_profit_price=None, tech_params=None, reason=''):
    """ä¸‹å•å‡½æ•°ï¼ˆé€‚é…åŠ¨æ€ä¹˜æ•°ï¼‰"""
    global current_position, daily_loss, position_entry_times, position_entry_prices, active_take_profit_orders, open_orders

    import time
    import random  # æ·»åŠ randomæ¨¡å—å¯¼å…¥
    
    # æ¨¡æ‹Ÿè®¢å•IDç”Ÿæˆ
    order_id = f"ORDER_{int(time.time())}_{random.randint(1000, 9999)}"
    
    # Production guard: do not allow real trading unless explicitly enabled
    if RUN_ENV == 'production' and os.getenv('ALLOW_REAL_TRADING', '0') != '1':
        print(f"âŒ ç”Ÿäº§æ¨¡å¼ä¸‹æœªå¯ç”¨çœŸå®äº¤æ˜“ (ALLOW_REAL_TRADING!=1)ï¼Œæ‹’ç»ä¸‹å• {side} {quantity} @ {price}")
        return False

    # æ£€æŸ¥æ˜¯å¦ä¸ºæ¨¡æ‹Ÿæ¨¡å¼
    if api_manager.is_mock_mode:
        # æ¨¡æ‹Ÿä¸‹å•æˆåŠŸ
        print(f"âœ… [æ¨¡æ‹Ÿå•] ä¸‹å•æˆåŠŸ | {side} {quantity}æ‰‹ | ä»·æ ¼ï¼š{price:.2f} | è®¢å•IDï¼š{order_id}")
        
        # å¦‚æœè®¾ç½®äº†æ­¢ç›ˆå•
        if take_profit_price is not None:
            tp_order_id = f"TP_{int(time.time())}_{random.randint(1000, 9999)}"
            print(f"ğŸ§­ [æ¨¡æ‹Ÿå•] å·²æäº¤æ­¢ç›ˆå• | {side} {quantity}æ‰‹ | ä»·æ ¼ï¼š{take_profit_price:.2f} | è®¢å•IDï¼š{tp_order_id}")
            
            # è®°å½•æ­¢ç›ˆå•åˆ°active_take_profit_orders
            for i in range(quantity):
                pos_id = f"{order_id}_tp_{i+1}"
                active_take_profit_orders[pos_id] = {
                    'quantity': 1,
                    'target_price': take_profit_price,
                    'submit_time': time.time(),  # è®°å½•æäº¤æ—¶é—´
                    'entry_price': price,        # è®°å½•å…¥åœºä»·æ ¼
                    'type': 'take_profit'
                }
        
        # å¦‚æœè®¾ç½®äº†æ­¢æŸå•
        if stop_loss_price is not None:
            sl_order_id = f"SL_{int(time.time())}_{random.randint(1000, 9999)}"
            print(f"ğŸ›¡ï¸ [æ¨¡æ‹Ÿå•] å·²æäº¤æ­¢æŸå• | {side} {quantity}æ‰‹ | ä»·æ ¼ï¼š{stop_loss_price:.2f} | è®¢å•IDï¼š{sl_order_id}")
    
    else:
        # å®é™…ä¸‹å•é€»è¾‘
        try:
            # æ ¹æ®ä¹°å–æ–¹å‘é€‰æ‹©å¯¹åº”çš„API
            trade_api = api_manager.trade_api
            
            # å‡†å¤‡è®¢å•å‚æ•°
            order_params = {
                'symbol': FUTURE_SYMBOL,
                'order_type': OrderType.MARKET,
                'quantity': quantity,
                'side': TradeDirection.BUY if side == 'BUY' else TradeDirection.SELL
            }
            
            # å¦‚æœæŒ‡å®šäº†ä»·æ ¼ï¼Œåˆ™ä½¿ç”¨é™ä»·å•
            if price is not None:
                order_params['order_type'] = OrderType.LIMIT
                order_params['limit_price'] = price
            
            # æäº¤è®¢å•
            order_result = trade_api.place_order(**order_params)
            order_id = order_result.get('order_id')
            
            print(f"âœ… [å®ç›˜å•] ä¸‹å•æˆåŠŸ | {side} {quantity}æ‰‹ | è®¢å•IDï¼š{order_id}")
            
        except Exception as e:
            print(f"âŒ ä¸‹å•å¤±è´¥ï¼š{e}")
            return False
    
    # æ›´æ–°ç®€å• in-memory state consistent with previous behavior
    if side == 'BUY':
        current_position += quantity
        
        # è®°å½•ä¹°å•åˆ°open_ordersï¼Œç”¨äºè·Ÿè¸ªäº¤æ˜“é—­ç¯
        for i in range(quantity):
            individual_order_id = f"{order_id}_qty_{i+1}"
            open_orders[individual_order_id] = {
                'quantity': 1,  # æ¯ä¸ªè®¢å•é¡¹ä»£è¡¨1æ‰‹
                'price': price,
                'timestamp': time.time(),
                'type': 'buy',
                'tech_params': tech_params or {},  # æŠ€æœ¯å‚æ•°
                'reason': reason                   # å¼€ä»“åŸå› 
            }
        
        # è®°å½•æ–°ä¹°å…¥æŒä»“çš„å…¥åœºæ—¶é—´å’Œä»·æ ¼
        for pos_id in range(current_position - quantity, current_position):
            position_entry_times[pos_id] = time.time()
            position_entry_prices[pos_id] = price
    else:  # SELL
        current_position -= quantity
        if current_position < 0:
            current_position = 0  # é˜²æ­¢è´ŸæŒä»“
        
        # æŒ‰å…ˆè¿›å…ˆå‡ºçš„åŸåˆ™åŒ¹é…ä¹°å•è¿›è¡Œå¹³ä»“
        remaining_qty_to_sell = quantity
        while remaining_qty_to_sell > 0 and open_orders:
            # è·å–æœ€æ—©çš„ä¹°å• - åœ¨Python 3.7ä¹‹å‰ï¼Œpopitem()ä¸æ¥å—lastå‚æ•°
            oldest_buy_order_id = next(iter(open_orders))
            buy_info = open_orders.pop(oldest_buy_order_id)
            
            if buy_info['quantity'] <= remaining_qty_to_sell:
                # å®Œå…¨å¹³ä»“
                sell_order_id = f"{order_id}_sold_{oldest_buy_order_id.split('_')[-1]}"
                closed_positions[sell_order_id] = {
                    'buy_order_id': oldest_buy_order_id,
                    'buy_price': buy_info['price'],
                    'sell_price': price,
                    'quantity': buy_info['quantity'],
                    'pnl': (price - buy_info['price']) * buy_info['quantity'] * FUTURE_MULTIPLIER,
                    'buy_timestamp': buy_info['timestamp'],
                    'sell_timestamp': time.time()
                }
                
                remaining_qty_to_sell -= buy_info['quantity']
            else:
                # éƒ¨åˆ†å¹³ä»“
                partial_qty = remaining_qty_to_sell
                sell_order_id = f"{order_id}_sold_partial_{oldest_buy_order_id.split('_')[-1]}"
                closed_positions[sell_order_id] = {
                    'buy_order_id': oldest_buy_order_id,
                    'buy_price': buy_info['price'],
                    'sell_price': price,
                    'quantity': partial_qty,
                    'pnl': (price - buy_info['price']) * partial_qty * FUTURE_MULTIPLIER,
                    'buy_timestamp': buy_info['timestamp'],
                    'sell_timestamp': time.time()
                }
                
                # æ›´æ–°å‰©ä½™ä¹°å•æ•°é‡
                remaining_buy_qty = buy_info['quantity'] - partial_qty
                if remaining_buy_qty > 0:
                    # å°†å‰©ä½™éƒ¨åˆ†æ”¾å›é˜Ÿåˆ—å¼€å¤´
                    open_orders[oldest_buy_order_id] = {
                        **buy_info,
                        'quantity': remaining_buy_qty
                    }
                
                remaining_qty_to_sell = 0
    
    return True


def check_active_take_profits(current_price):
    """æ£€æŸ¥ä¸»åŠ¨æ­¢ç›ˆ"""
    global current_position, active_take_profit_orders, position_entry_times, position_entry_prices
    
    import time
    
    if current_position <= 0:
        return False
    
    positions_to_close = []
    
    for pos_id in list(active_take_profit_orders.keys()):
        if pos_id in active_take_profit_orders:
            tp_info = active_take_profit_orders[pos_id]
            target_price = tp_info['target_price']
            
            # æ£€æŸ¥å½“å‰ä»·æ ¼æ˜¯å¦è¾¾åˆ°æœ€ä½ç›ˆåˆ©ç›®æ ‡æˆ–æœ€ä½ç›ˆåˆ©æ¯”ç‡
            entry_price = position_entry_prices.get(pos_id, 0)
            min_profit_price = entry_price * (1.0 + MIN_PROFIT_RATIO) if entry_price else None

            # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ä»»ä¸€æ­¢ç›ˆè§¦å‘æ¡ä»¶ï¼šç›®æ ‡ä»·ã€æœ€ä½ç›ˆåˆ©æ¯”ç‡ã€æˆ–å·²è¶…æ—¶
            submit_time = tp_info.get('submit_time', 0)
            elapsed_minutes = (time.time() - submit_time) / 60 if submit_time else 0

            if (target_price is not None and current_price >= target_price) or \
               (min_profit_price is not None and current_price >= min_profit_price) or \
               (elapsed_minutes >= TAKE_PROFIT_TIMEOUT):
                positions_to_close.append({
                    'pos_id': pos_id,
                    'quantity': tp_info['quantity'],
                    'entry_price': position_entry_prices.get(pos_id, 0),
                    'current_price': current_price,
                    'target_price': target_price,
                    'entry_reason': tp_info.get('entry_reason', ''),
                    'entry_tech_params': tp_info.get('entry_tech_params', {})
                })
    
    # æ‰§è¡Œä¸»åŠ¨æ­¢ç›ˆ
    if positions_to_close:
        total_quantity = sum(item['quantity'] for item in positions_to_close)
        print(f"ğŸ”„ æ‰§è¡Œä¸»åŠ¨æ­¢ç›ˆï¼š{len(positions_to_close)}ä¸ªå¤´å¯¸ï¼Œæ€»æ•°é‡{total_quantity}æ‰‹")
        
        for item in positions_to_close:
            pos_id = item['pos_id']
            print(f"   - Pos #{pos_id}: ä¹°å…¥ä»· {item['entry_price']:.2f} -> å½“å‰ä»· {item['current_price']:.2f} "
                  f"(ç›®æ ‡ {item['target_price']:.2f})")
            
            # æ‰§è¡Œå¹³ä»“ï¼Œæ ‡è®°ä¸ºè‡ªåŠ¨æ­¢ç›ˆ
            # call with positional args to satisfy tests that assert call signature
            place_tiger_order('SELL', item['quantity'], current_price)
            
            # æ¸…ç†ç›¸å…³è®°å½•
            if pos_id in active_take_profit_orders:
                del active_take_profit_orders[pos_id]
            if pos_id in position_entry_times:
                del position_entry_times[pos_id]
            if pos_id in position_entry_prices:
                del position_entry_prices[pos_id]
        
        return True
    
    return False


def check_timeout_take_profits(current_price):
    """æ£€æŸ¥è¶…æ—¶æ­¢ç›ˆ"""
    global current_position, active_take_profit_orders, position_entry_times, position_entry_prices
    
    import time
    
    if current_position <= 0:
        return False
    
    positions_to_close = []
    
    for pos_id in list(active_take_profit_orders.keys()):
        if pos_id in active_take_profit_orders:
            tp_info = active_take_profit_orders[pos_id]
            submit_time = tp_info['submit_time']
            target_price = tp_info['target_price']
            
            # æ£€æŸ¥æ­¢ç›ˆå•æ˜¯å¦è¶…æ—¶
            elapsed_minutes = (time.time() - submit_time) / 60

            # æ£€æŸ¥å½“å‰ä»·æ ¼æ˜¯å¦è¾¾åˆ°æœ€ä½ç›ˆåˆ©ç›®æ ‡
            entry_price = position_entry_prices.get(pos_id, 0)
            
            # è¶…æ—¶åï¼Œåªè¦è¾¾åˆ°ç›®æ ‡ç›ˆåˆ©çš„ 1/3 ä¹Ÿå¯ä¸»åŠ¨æ­¢ç›ˆ
            tp_one_third = None
            try:
                if entry_price > 0 and target_price > entry_price:
                    tp_one_third = entry_price + (target_price - entry_price) / 3
                else:
                    tp_one_third = target_price
            except Exception:
                tp_one_third = target_price

            timed_out_trigger = elapsed_minutes >= TAKE_PROFIT_TIMEOUT and current_price >= tp_one_third

            if timed_out_trigger:
                positions_to_close.append({
                    'pos_id': pos_id,
                    'quantity': tp_info['quantity'],
                    'entry_price': entry_price,
                    'current_price': current_price,
                    'target_price': target_price,
                    'elapsed_minutes': elapsed_minutes,
                    'entry_reason': tp_info.get('entry_reason', ''),
                    'entry_tech_params': tp_info.get('entry_tech_params', {})
                })
    
    # æ‰§è¡Œè¶…æ—¶æ­¢ç›ˆ
    if positions_to_close:
        total_quantity = sum(item['quantity'] for item in positions_to_close)
        print(f"ğŸ”„ æ‰§è¡Œè¶…æ—¶æ­¢ç›ˆï¼š{len(positions_to_close)}ä¸ªå¤´å¯¸ï¼Œæ€»æ•°é‡{total_quantity}æ‰‹")
        
        for item in positions_to_close:
            pos_id = item['pos_id']
            print(f"   - Pos #{pos_id}: ä¹°å…¥ä»· {item['entry_price']:.2f} -> å½“å‰ä»· {item['current_price']:.2f} "
                  f"(ç›®æ ‡ {item['target_price']:.2f}, å·²ç­‰å¾… {item['elapsed_minutes']:.1f}åˆ†é’Ÿ)")
            
            # æ‰§è¡Œå¹³ä»“ï¼Œæ ‡è®°ä¸ºè¶…æ—¶æ­¢ç›ˆ
            # call with positional args to satisfy tests that assert call signature
            place_tiger_order('SELL', item['quantity'], current_price)
            
            # æ¸…ç†ç›¸å…³è®°å½•
            if pos_id in active_take_profit_orders:
                del active_take_profit_orders[pos_id]
            if pos_id in position_entry_times:
                del position_entry_times[pos_id]
            if pos_id in position_entry_prices:
                del position_entry_prices[pos_id]
        
        return True
    
    return False


def place_take_profit_order(entry_side: str, quantity: int, take_profit_price: float) -> bool:
    """
    æäº¤æ­¢ç›ˆè®¢å•ï¼Œå¤„ç†ä»·æ ¼ç²¾åº¦è°ƒæ•´å’Œå¼‚å¸¸æƒ…å†µ
    """
    try:
        # ç¡®å®šè®¢å•æ–¹å‘ - ä¸å…¥åœºæ–¹å‘ç›¸å
        exit_side = 'SELL' if entry_side == 'BUY' else 'BUY'
        
        def _build_tp_order(adj_price):
            """å†…éƒ¨å‡½æ•°ï¼Œç”¨äºæ„å»ºæ­¢ç›ˆè®¢å•"""
            # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…æƒ…å†µæ„å»ºè®¢å•å¯¹è±¡
            # ç”±äºä¸çŸ¥é“å…·ä½“çš„è®¢å•å¯¹è±¡æ ¼å¼ï¼Œæš‚æ—¶ç•™ç©º
            pass
        
        # ä»é…ç½®è·å–æœ€å°åˆ»åº¦
        min_tick = 0.01

        # round target price to nearest tick using Decimal for safe rounding
        try:
            from decimal import Decimal, ROUND_HALF_UP
            tick_d = Decimal(str(min_tick))
            price_d = Decimal(str(take_profit_price))
            multiplier = (price_d / tick_d).quantize(Decimal('1'), rounding=ROUND_HALF_UP)
            adj_price = float((multiplier * tick_d).normalize())
        except Exception:
            # fallback simple round
            try:
                adj_price = round(take_profit_price / min_tick) * min_tick
            except Exception:
                adj_price = take_profit_price

        # If adjusted price equals original, no point retrying
        if abs(adj_price - float(take_profit_price)) < 1e-12:
            # fall through to sandbox logging or failure
            pass
        else:
            try:
                tp_order2 = _build_tp_order(adj_price)
                # å‡è®¾trade_clientæ˜¯å·²åˆå§‹åŒ–çš„å®¢æˆ·ç«¯
                # trade_client.place_order(tp_order2)
                print(f"ğŸ§­ å·²æäº¤ç‹¬ç«‹æ­¢ç›ˆå•ï¼ˆè°ƒæ•´åˆ°tickï¼‰ | {exit_side} {quantity}æ‰‹ | ä»·æ ¼ï¼š{float(adj_price):.2f} (åŸä»· {float(take_profit_price):.2f})")
                return True
            except Exception as e2:
                # replace primary exception message with combined info for logging
                e = Exception(f"åŸå§‹å¼‚å¸¸: {e}; é‡è¯•å¼‚å¸¸ï¼ˆä»·æ ¼è°ƒæ•´è‡³{adj_price}ï¼‰: {e2}")

        # If we're in sandbox, ignore failures but log for visibility
        if RUN_ENV == 'sandbox':
            try:
                print(f"ğŸ§­ [æ¨¡æ‹Ÿ] æ­¢ç›ˆå•æäº¤å¤±è´¥ï¼ˆå¿½ç•¥ï¼‰ | ä»·æ ¼ï¼š{float(take_profit_price):.2f} | åŸå› ï¼š{e}")
            except Exception:
                print(f"ğŸ§­ [æ¨¡æ‹Ÿ] æ­¢ç›ˆå•æäº¤å¤±è´¥ï¼ˆå¿½ç•¥ï¼‰ | ä»·æ ¼ï¼š{take_profit_price} | åŸå› ï¼šé”™è¯¯ä¿¡æ¯ä¸å¯æ‰“å°")
            return True

        # logger.warning("place_take_profit_order failed: %s", e)
        return False
    except Exception as e:
        if RUN_ENV == 'sandbox':
            print(f"ğŸ§­ [æ¨¡æ‹Ÿ] æ­¢ç›ˆå•æäº¤å¤±è´¥ï¼ˆå¿½ç•¥ï¼‰ | ä»·æ ¼ï¼š{float(take_profit_price):.2f} | åŸå› ï¼š{e}")
            return True
        # logger.warning("place_take_profit_order outer failure: %s", e)
        return False

def grid_trading_strategy():
    """æ ¸å¿ƒç½‘æ ¼ç­–ç•¥é€»è¾‘ï¼ˆé€»è¾‘ä¸å˜ï¼‰"""
    df_1m = get_kline_data([FUTURE_SYMBOL], '1min', count=30)
    df_5m = get_kline_data([FUTURE_SYMBOL], '5min', count=50)
    if df_1m.empty or df_5m.empty:
        print("âš ï¸ æ•°æ®ä¸è¶³ï¼Œè·³è¿‡æœ¬STEP 22")
        return
    
    indicators = calculate_indicators(df_1m, df_5m)
    if not indicators or '5m' not in indicators or '1m' not in indicators:
        print("âš ï¸ æŒ‡æ ‡è®¡ç®—å¤±è´¥ï¼Œè·³è¿‡æœ¬æ¬¡å¾ªç¯33")
        return
    
    trend = judge_market_trend(indicators)
    adjust_grid_interval(trend, indicators)
    
    price_current = indicators['1m']['close']
    rsi_1m = indicators['1m']['rsi']
    rsi_5m = indicators['5m']['rsi']
    atr = indicators['5m']['atr']
    
    rsi_low_map = {
        'boll_divergence_down': 15,
        'osc_bear': 22,
        'osc_bull': 55,
        'bull_trend': 50,
        'osc_normal': 25
    }
    rsi_reverse_map = {
        'boll_divergence_down': 30,
        'osc_bear': 30,
        'osc_bull': 60,
        'bull_trend': 55,
        'osc_normal': 30
    }
    rsi_low = rsi_low_map.get(trend, 25)
    rsi_reverse = rsi_reverse_map.get(trend, 30)
    
    if price_current <= grid_lower and rsi_1m <= rsi_low and check_risk_control(price_current, 'BUY'):
        trend_check = (trend in ['osc_bull', 'bull_trend'] and rsi_5m > 50) or \
                      (trend in ['osc_bear', 'boll_divergence_down'] and rsi_5m < 50)
        # If trend check passes, place buy (removed impossible dual-RSI check present previously)
        if trend_check:
            stop_loss_price, projected_loss = compute_stop_loss(price_current, atr, grid_lower)
            if stop_loss_price is None or not math.isfinite(projected_loss):
                print("âš ï¸ æ­¢æŸè®¡ç®—å¼‚å¸¸ï¼Œè·³è¿‡ä¹°å…¥")
                return
            # compute TP level with buffer below grid_upper to improve fills
            min_tick = 0.01
            try:
                min_tick = float(FUTURE_TICK_SIZE)
            except Exception:
                pass
            tp_offset = max(TAKE_PROFIT_ATR_OFFSET * (atr if atr else 0), TAKE_PROFIT_MIN_OFFSET)
            take_profit_price = max(price_current + min_tick, (grid_upper - tp_offset) if grid_upper is not None else price_current + min_tick)
            place_tiger_order('BUY', 1, price_current, stop_loss_price)
            try:
                place_take_profit_order('BUY', 1, take_profit_price)
            except Exception:
                pass

    # ä¸­æ–‡è¯´æ˜ï¼š
    # - æ­¤å‡½æ•°å®ç°äº†æœ€åŸºç¡€çš„ç½‘æ ¼äº¤æ˜“é€»è¾‘ï¼šåœ¨ä»·æ ¼è§¦åŠç½‘æ ¼ä¸‹è½¨å¹¶ä¸” 1 åˆ†é’Ÿ RSI ä½äºé˜ˆå€¼æ—¶å°è¯•ä¹°å…¥ï¼›
    # - ä¸‹å•å‰ä¼šå…ˆé€šè¿‡ `check_risk_control` åšä»“ä½ä¸äºæŸæ£€æŸ¥ï¼›å¦‚æœä¹°å…¥æˆåŠŸä¼šå°è¯•æäº¤ç‹¬ç«‹çš„æ­¢ç›ˆå•ï¼›
    # - å–å‡ºï¼ˆæ­¢ç›ˆ/æ­¢æŸï¼‰é€»è¾‘ä¹Ÿåœ¨æ­¤å®ç°ï¼šå½“ä»·æ ¼è§¦åŠä¸Šè½¨æˆ–æ»¡è¶³ä¸»åŠ¨æ­¢ç›ˆæ¡ä»¶æ—¶å–å‡ºï¼Œæˆ–è§¦åŠæ­¢æŸä»·æ—¶å…¨éƒ¨å¹³ä»“ã€‚
    
    # æ£€æŸ¥ä¸»åŠ¨æ­¢ç›ˆ
    check_active_take_profits(price_current)
    
    rsi_high_map = {
        'boll_divergence_up': 80,
        'osc_bull': 75,
        'bull_trend': 70,
        'osc_normal': 70
    }
    rsi_high = rsi_high_map.get(trend, 70)
    
    # ä¿®æ”¹ï¼šæ·»åŠ å–å‡ºæ¡ä»¶é™åˆ¶ï¼Œé˜²æ­¢é‡å¤å–å‡º
    if price_current >= grid_upper and rsi_1m >= rsi_high and current_position > 0:
        print(f"ğŸ¯ è§¦å‘ç½‘æ ¼å–å‡ºæ¡ä»¶: ä»·æ ¼({price_current:.2f}) â‰¥ ç½‘æ ¼ä¸Šè½¨({grid_upper:.2f}), RSI({rsi_1m:.2f}) â‰¥ é˜ˆå€¼({rsi_high:.2f})")
        place_tiger_order('SELL', 1, price_current)
    
    if current_position > 0:
        ref_entry = None
        try:
            if position_entry_prices:
                ref_entry = sum(position_entry_prices.values()) / len(position_entry_prices)
        except Exception:
            ref_entry = None

        stop_loss_price, _ = compute_stop_loss(ref_entry if ref_entry is not None else price_current, atr, grid_lower)
        if price_current <= stop_loss_price:
            env_tip = "[æ¨¡æ‹Ÿæ­¢æŸ]" if RUN_ENV == 'sandbox' else "[å®ç›˜æ­¢æŸ]"
            print(f"âš ï¸ {env_tip} è§¦å‘æ­¢æŸï¼Œå¹³ä»“{current_position}æ‰‹")
            place_tiger_order('SELL', current_position, price_current)


def grid_trading_strategy_pro1():
    """Enhanced grid strategy variant (pro1):
    - Adds a small buffer above `grid_lower` (based on ATR) to allow "near lower" entries
    - Relaxes 1m RSI slightly
    - Accepts momentum (last > prev) or volume spike as alternative confirmations
    - Keeps `check_risk_control` as the final gate
    """
    global current_position

    # Track whether we executed a sell in this iteration to prevent multiple sells in one cycle
    initial_position = current_position
    sold_this_iteration = False

    # Fetch market data
    df_1m = get_kline_data([FUTURE_SYMBOL], '1min', count=30)
    df_5m = get_kline_data([FUTURE_SYMBOL], '5min', count=50)
    if df_1m.empty or df_5m.empty:
        print("âš ï¸ æ•°æ®ä¸è¶³ï¼Œè·³è¿‡ grid_trading_strategy_pro1")
        return

    indicators = calculate_indicators(df_1m, df_5m)
    if not indicators or '5m' not in indicators or '1m' not in indicators:
        print("âš ï¸ æŒ‡æ ‡è®¡ç®—å¤±è´¥ï¼Œè·³è¿‡ grid_trading_strategy_pro1")
        return

    trend = judge_market_trend(indicators)
    adjust_grid_interval(trend, indicators)

    price_current = indicators['1m']['close']
    rsi_1m = indicators['1m']['rsi']
    rsi_5m = indicators['5m']['rsi']
    atr = indicators['5m']['atr']

    rsi_low_map = {
        'boll_divergence_down': 15,
        'osc_bear': 22,
        'osc_bull': 55,
        'bull_trend': 50,
        'osc_normal': 25
    }
    rsi_low = rsi_low_map.get(trend, 25)

    # 1) buffer above lower band (safe fallback when atr==0)
    buffer = max(0.3 * (atr if atr else 0), 0.0025)
    near_lower = price_current <= (grid_lower + buffer)


    # 2) RSI acceptance: oversold OR reversal OR bullish divergence
    oversold_ok = False
    rsi_rev_ok = False
    rsi_div_ok = False
    try:
        oversold_ok = (rsi_1m is not None) and (rsi_1m <= (rsi_low + 5))

        # build recent RSI series (prefer precomputed, else compute)
        try:
            rsis = df_1m['rsi']
        except Exception:
            rsis = talib.RSI(df_1m['close'], timeperiod=GRID_RSI_PERIOD_1M)

        rsis = rsis.dropna() if hasattr(rsis, 'dropna') else rsis
        rsi_prev = float(rsis.iloc[-2]) if hasattr(rsis, 'iloc') and len(rsis) >= 2 else None
        rsi_cap = (rsi_low + 12)

        # reversal: RSI crosses above 50 from below
        if (rsi_prev is not None) and (rsi_1m is not None):
            rsi_rev_ok = (rsi_prev < 50) and (rsi_1m >= 50)

        # bullish divergence: price makes lower low while RSI makes higher low
        try:
            lows = df_1m['low'].dropna()
            low_prev = float(lows.iloc[-2]) if len(lows) >= 2 else None
            low_cur = float(lows.iloc[-1]) if len(lows) >= 1 else None
            rsi_div_ok = (low_cur is not None and low_prev is not None and rsi_prev is not None and
                          (low_cur < low_prev) and (rsi_1m is not None) and (rsi_1m > rsi_prev) and (rsi_1m <= rsi_cap))
        except Exception:
            rsi_div_ok = False
    except Exception:
        oversold_ok = False
        rsi_rev_ok = False
        rsi_div_ok = False

    rsi_ok = oversold_ok or rsi_rev_ok or rsi_div_ok

    # 3) relaxed trend check
    trend_check = (trend in ['osc_bull', 'bull_trend'] and rsi_5m > 45) or \
                  (trend in ['osc_bear', 'boll_divergence_down'] and rsi_5m < 55)

    # 4) momentum / volume backups
    rebound = False
    vol_ok = False
    try:
        closes = df_1m['close'].dropna()
        last = float(closes.iloc[-1])
        prev = float(closes.iloc[-2]) if len(closes) >= 2 else None
        rebound = (prev is not None and last > prev)
        vols = df_1m['volume'].dropna()
        if len(vols) >= 6:
            window = vols.iloc[-6:-1]
            recent_mean = window.mean()
            recent_median = window.median()
            rmax = window.max()
            mean_up = recent_mean * 1.05
            med_up = recent_median * 1.01
            max_up = rmax * 0.95
            threshold = max(mean_up, med_up, max_up)
            vol_ok = vols.iloc[-1] >= max(threshold, 0)
    except Exception:
        rebound = False
        vol_ok = False

    # Final buy decision: near_lower + rsi_ok + (trend_check or rebound or vol_ok)
    if near_lower and rsi_ok and (trend_check or rebound or vol_ok) and check_risk_control(price_current, 'BUY'):
        stop_loss_price, projected_loss = compute_stop_loss(price_current, atr, grid_lower)
        if stop_loss_price is None or not math.isfinite(projected_loss):
            print("âš ï¸ æ­¢æŸè®¡ç®—å¼‚å¸¸ï¼Œè·³è¿‡ä¹°å…¥(pro1)")
            return
        # compute TP with buffer below grid_upper
        min_tick = 0.01
        try:
            min_tick = float(FUTURE_TICK_SIZE)
        except Exception:
            pass
        tp_offset = max(TAKE_PROFIT_ATR_OFFSET * (atr if atr else 0), TAKE_PROFIT_MIN_OFFSET)
        take_profit_price = max(price_current + min_tick, (grid_upper - tp_offset) if grid_upper is not None else price_current + min_tick)
        print(
            f"ğŸ”§ grid_trading_strategy_pro1: è§¦å‘ä¹°å…¥æ¡ä»¶ -> price={price_current:.4f}, "
            f"rsi_1m={rsi_1m}, rsi_5m={rsi_5m}, atr={atr}, buffer={buffer:.4f}, near_lower={near_lower}, "
            f"rsi_ok={rsi_ok}, trend_check={trend_check}, rebound={rebound}, vol_ok={vol_ok}, "
            f"grid_lower={grid_lower}, grid_upper={grid_upper}, stop_loss={stop_loss_price:.4f}, tp={take_profit_price:.4f}"
        )
        place_tiger_order('BUY', 1, price_current, stop_loss_price)
        try:
            place_take_profit_order('BUY', 1, take_profit_price)
        except Exception:
            pass
    else:
        print(f"ğŸ”§ grid_trading_strategy_pro1 è®¡ç®—è¯¦æƒ…:")
        print(f"   å½“å‰ä»·æ ¼: {price_current}")
        print(f"   ç½‘æ ¼ä¸‹è½¨: {grid_lower}")
        print(f"   ATRå€¼: {atr}")
        print(f"   Bufferè®¡ç®—: max(0.05 * {atr}, 0.0025) = {buffer}")
        print(f"   é˜ˆå€¼è®¡ç®—: {grid_lower} + {buffer} = {grid_lower + buffer}")
        print(f"   near_lower: {price_current} <= {grid_lower + buffer} = {near_lower}")
        print(f"   rsi_ok: {rsi_ok} (oversold_ok={oversold_ok}, rsi_rev_ok={rsi_rev_ok}, rsi_div_ok={rsi_div_ok})")
        print(f"   trend_check: {trend_check}")
        print(f"   rebound: {rebound}")
        print(f"   vol_ok: {vol_ok}")
        print(f"ğŸ”§ grid_trading_strategy_pro1: æœªè§¦å‘ï¼ˆnear_lower={near_lower}, rsi_ok={rsi_ok}, trend_check={trend_check}, rebound={rebound}, vol_ok={vol_ok}ï¼‰")

    # æ£€æŸ¥ä¸»åŠ¨æ­¢ç›ˆ - ä»…åœ¨æœ‰æŒä»“æ—¶æ£€æŸ¥
    if current_position > 0:
        sold_this_iteration = check_active_take_profits(price_current)
    
    # å¦‚æœä¸»åŠ¨æ­¢ç›ˆå·²ç»æ‰§è¡Œï¼Œä¸å†æ£€æŸ¥å…¶ä»–å–å‡ºæ¡ä»¶
    if not sold_this_iteration and current_position > 0:
        # Fallback exits if TP wasn't attached/filled: sell when price reaches grid_upper
        # TP fallback: sell when reaching buffered TP level (below grid_upper)
        min_tick = 0.01
        try:
            min_tick = float(FUTURE_TICK_SIZE)
        except Exception:
            pass
        tp_offset = max(TAKE_PROFIT_ATR_OFFSET * (atr if atr else 0), TAKE_PROFIT_MIN_OFFSET)
        tp_level = None if grid_upper is None else max((grid_upper - tp_offset), (price_current + min_tick) if price_current is not None else (grid_upper - tp_offset))
        
        if price_current is not None and tp_level is not None and price_current >= tp_level:
            print(f"ğŸ”§ grid_trading_strategy_pro1: è§¦å‘å–å‡º at {price_current:.2f} (tp_level={tp_level:.2f})")
            place_tiger_order('SELL', 1, price_current)
            sold_this_iteration = True

    # Only check stop-loss if no other sell operation happened in this iteration
    if current_position > 0 and not sold_this_iteration:
        ref_entry = None
        try:
            if position_entry_prices:
                # åªè€ƒè™‘å½“å‰ä»æŒæœ‰çš„ä»“ä½çš„å¹³å‡æˆæœ¬
                held_positions = [pos_id for pos_id in range(current_position)]
                if held_positions:
                    ref_entry = sum(position_entry_prices.get(pos_id, 0) for pos_id in held_positions) / len(held_positions)
        except Exception:
            ref_entry = None

        stop_loss_price, _ = compute_stop_loss(ref_entry if ref_entry is not None else price_current, atr, grid_lower)
        if price_current <= stop_loss_price:
            env_tip = "[æ¨¡æ‹Ÿæ­¢æŸ]" if RUN_ENV == 'sandbox' else "[å®ç›˜æ­¢æŸ]"
            print(f"âš ï¸ {env_tip} è§¦å‘æ­¢æŸï¼Œå¹³ä»“{current_position}æ‰‹")
            place_tiger_order('SELL', current_position, price_current)
            sold_this_iteration = True
            
    # å¦‚æœåœ¨æ­¤æ¬¡è¿­ä»£ä¸­æœ‰å–å‡ºæ“ä½œï¼Œæ‰“å°ç›¸å…³ä¿¡æ¯
    if initial_position > current_position:
        print(f"ğŸ“ˆ {FUTURE_SYMBOL} ä»“ä½å˜åŒ–: {initial_position} â†’ {current_position} æ‰‹")
    
    # æ‰“å°å½“å‰æŒä»“æ‘˜è¦
    if current_position > 0:
        avg_cost = sum(list(position_entry_prices.values())[:current_position]) / current_position if position_entry_prices else 0
        current_profit = (price_current - avg_cost) * current_position * FUTURE_MULTIPLIER
        print(f"ğŸ“Š æŒä»“æ‘˜è¦: å¹³å‡æˆæœ¬={avg_cost:.2f}, å½“å‰ä»·æ ¼={price_current:.2f}, æŒä»“ç›ˆäº={current_profit:.2f}USD")


def boll1m_grid_strategy():
    """1-minute Bollinger-based grid strategy (ç‹¬ç«‹å‡½æ•°) â€” ä¼˜åŒ–è¿‡çš„å¼€ä»“é€»è¾‘ã€‚

    åœºæ™¯åŒºåˆ†ï¼š
      - éœ‡è¡ä¸Šè¡Œï¼ˆosc_bull / osc_normalï¼‰: åœ¨ä»·æ ¼ä¸‹æ¢åˆ°ä¸‹è½¨å¹¶å‡ºç°åå¼¹ï¼ˆlast > prevï¼‰æ—¶å¼€ä»“
      - éœ‡è¡ä¸‹è¡Œï¼ˆosc_bearï¼‰æˆ–å•è¾¹ä¸‹è·Œï¼ˆbear_trend / boll_divergence_downï¼‰: åªåœ¨ä»·æ ¼ä»ä¸‹è½¨å›å‡å¹¶çªç ´ä¸‹è½¨æ—¶æ›´ä¸ºä¿å®ˆåœ°å¼€ä»“
      - å•è¾¹ä¸Šæ¶¨ï¼ˆbull_trend / boll_divergence_upï¼‰: å¯åœ¨ä¸‹æ¢å¹¶å‡ºç°åå¼¹æ—¶è¾ƒç§¯æå¼€ä»“

    å…·ä½“è§„åˆ™ï¼ˆç®€åŒ–ç‰ˆå®ç°ï¼‰:
      1. åœ¨æœ€è¿‘ 3 æ ¹ 1m K çº¿å†…å‡ºç°ä»·æ ¼ <= ä¸‹è½¨ï¼ˆdip_detectedï¼‰;
      2. æ ¹æ®è¶‹åŠ¿ç±»å‹è¦æ±‚ä¸åŒçš„åå¼¹ç¡®è®¤ï¼ˆå¦‚ last > prev æˆ– last >= boll_lowerï¼‰ï¼›
      3. é€šè¿‡é£æ§åä¸‹å•ï¼Œæ­¢æŸæŒ‰ ATR è®¡ç®—ã€‚

    å–å‡ºï¼šå½“æŒä»“ä¸”å½“å‰ä»·æ ¼ >= ä¸­è½¨æ—¶å–å‡º 1 æ‰‹ã€‚
    """
    # ä¸­æ–‡è¯´æ˜ï¼š
    # - ä½¿ç”¨ 1 åˆ†é’Ÿ BOLL æŒ‡æ ‡åˆ¤æ–­çŸ­æœŸå›æŠ½ä¸åå¼¹ï¼Œç”¨äºå¿«é€Ÿå°ä»“ä½å¼€ä»“
    # - åˆ†åœºæ™¯å¤„ç†ï¼šéœ‡è¡ä¸Šè¡Œã€éœ‡è¡ä¸‹è¡Œã€å•è¾¹ä¸Šæ¶¨ç­‰æƒ…å½¢æ—¶çš„å¼€ä»“/é£æ§ç­–ç•¥æœ‰æ‰€ä¸åŒ
    # - è¯¥å‡½æ•°è¢«å•å…ƒæµ‹è¯•é€šè¿‡ monkeypatch çš„æ–¹å¼è°ƒç”¨ï¼Œå‡½æ•°å†…éƒ¨å°½é‡é¿å…å¯¹å¤–éƒ¨çŠ¶æ€çš„å¼ºä¾èµ–
    global current_position

    # Track whether we executed a sell in this iteration
    sold_this_iteration = False

    # Fetch enough 1m bars for BOLL calculation
    df_1m = get_kline_data([FUTURE_SYMBOL], '1min', count=max(30, GRID_BOLL_PERIOD + 5))
    if df_1m.empty or len(df_1m) < GRID_BOLL_PERIOD:
        print("âš ï¸ boll1m_grid_strategy: æ•°æ®ä¸è¶³ï¼Œè·³è¿‡")
        return

    indicators = calculate_indicators(df_1m, df_1m)
    if '5m' not in indicators or '1m' not in indicators:
        print("âš ï¸ boll1m_grid_strategy: æŒ‡æ ‡è®¡ç®—å¤±è´¥ï¼Œè·³è¿‡")
        return

    boll_lower = indicators['5m']['boll_lower']
    boll_mid = indicators['5m']['boll_mid']
    price_current = indicators['1m']['close']
    atr = indicators['5m']['atr']

    # Determine market regime
    trend = judge_market_trend(indicators)

    # Gather recent closes for dip/rebound detection
    closes = None
    try:
        closes = df_1m['close'].dropna()
    except Exception:
        closes = pd.Series(dtype='float')

    if len(closes) < 2:
        print("âš ï¸ boll1m_grid_strategy: Kçº¿ä¸è¶³ä»¥åˆ¤æ–­åå¼¹ï¼Œè·³è¿‡")
        return

    last = float(closes.iloc[-1])
    prev = float(closes.iloc[-2]) if len(closes) >= 2 else None
    prev3_min = float(closes.tail(3).min()) if len(closes) >= 1 else None

    dip_detected = (boll_lower is not None and prev3_min is not None and prev3_min <= boll_lower)

    # Buy decision: require dip then rebound; stricter in downtrends
    buy_ok = False
    if dip_detected and price_current is not None and boll_lower is not None:
        if trend in ('osc_bull', 'osc_normal', 'bull_trend', 'boll_divergence_up'):
            # moderate: any rebound (last > prev) is acceptable
            if prev is not None and last > prev:
                buy_ok = True
        elif trend in ('osc_bear', 'bear_trend', 'boll_divergence_down'):
            # conservative: require rebound that reaches at least back to lower band
            if prev is not None and prev <= boll_lower and last >= boll_lower:
                buy_ok = True
        else:
            # default to moderate behaviour
            if prev is not None and last > prev:
                buy_ok = True

    if buy_ok:
        if check_risk_control(price_current, 'BUY'):
            stop_loss_price, projected_loss = compute_stop_loss(price_current, atr, boll_lower)
            if stop_loss_price is None or not math.isfinite(projected_loss):
                print("âš ï¸ boll1m_grid_strategy: æ­¢æŸè®¡ç®—å¼‚å¸¸ï¼Œè·³è¿‡ä¹°å…¥")
                return
            print(f"ğŸ”§ boll1m_grid_strategy ({trend}): å‘ç°å›è°ƒ+åå¼¹ï¼Œå‡†å¤‡ä¹°å…¥ at {price_current:.2f} (boll_lower={boll_lower:.2f})")
            place_tiger_order('BUY', 1, price_current, stop_loss_price)
        else:
            print("ğŸ”§ boll1m_grid_strategy: é£æ§é˜»æ­¢ä¹°å…¥")
    else:
        print(f"ğŸ”§ boll1m_grid_strategy ({trend}): æœªæ»¡è¶³å›è°ƒç¡®è®¤æˆ–æœªæ£€æµ‹åˆ°dipï¼ˆdip_detected={dip_detected}, last={last}, prev={prev}ï¼‰")

    # æ£€æŸ¥ä¸»åŠ¨æ­¢ç›ˆ
    if not sold_this_iteration:  # åªæœ‰åœ¨æœªæ‰§è¡Œå…¶ä»–å–å‡ºæ“ä½œæ—¶æ‰æ£€æŸ¥ä¸»åŠ¨æ­¢ç›ˆ
        sold_this_iteration = check_active_take_profits(price_current)

    # Sell at mid band when holding (unchanged)
    if current_position > 0 and not sold_this_iteration and price_current is not None and boll_mid is not None and price_current >= boll_mid:
        print(f"ğŸ”§ boll1m_grid_strategy: è§¦å‘å–å‡º at {price_current:.2f} (boll_mid={boll_mid:.2f})")
        place_tiger_order('SELL', 1, price_current)
        sold_this_iteration = True


def backtest_grid_trading_strategy_pro1(symbol: str = FUTURE_SYMBOL, bars_1m: int = 2000, bars_5m: int = 1000, lookahead: int = 120):
    """Run a simple event-driven backtest for `grid_trading_strategy_pro1`.

    Method:
    - Walk forward through 1m bars; at each step, compute indicators on history-to-date
      and apply the pro1 buy logic (near_lower + rsi_ok + trend/rebound/vol_ok).
        - When a buy triggers, set target at current `grid_upper` and stop via
            `compute_stop_loss` (ATR ä¸‹é™ + ä¸‹è½¨ç»“æ„ç¼“å†² + å•ç¬”äºæŸä¸Šé™)ã€‚
    - Scan forward up to `lookahead` 1m bars: if low <= stop first -> loss; if high >= target first -> win.
      If neither is hit within the window, count as unresolved and skip from metrics.

    Returns a dict with metrics and prints a concise summary.
    """
    try:
        df_1m = get_kline_data([symbol], '1min', count=bars_1m)
        df_5m = get_kline_data([symbol], '5min', count=bars_5m)
        if df_1m.empty or df_5m.empty:
            print("âš ï¸ backtest_pro1: æ•°æ®ä¸è¶³ï¼Œæ— æ³•è®¡ç®—ã€‚è¯·æ£€æŸ¥APIè¿æ¥æˆ–å¢å¤§countã€‚")
            return None

        wins = 0
        losses = 0
        unresolved = 0
        rr_list = []

        i = max(GRID_BOLL_PERIOD, 10)
        while i < len(df_1m) - 1:
            # Slice history up to current index
            sub1 = df_1m.iloc[:i+1]
            t_cur = sub1.index[-1]
            sub5 = df_5m[df_5m.index <= t_cur]

            inds = calculate_indicators(sub1, sub5)
            if '5m' not in inds or '1m' not in inds:
                i += 1
                continue

            trend = judge_market_trend(inds)
            adjust_grid_interval(trend, inds)

            price_current = inds['1m']['close']
            rsi_1m = inds['1m']['rsi']
            rsi_5m = inds['5m']['rsi']
            atr = inds['5m']['atr']

            rsi_low_map = {
                'boll_divergence_down': 15,
                'osc_bear': 22,
                'osc_bull': 55,
                'bull_trend': 50,
                'osc_normal': 25
            }
            rsi_low = rsi_low_map.get(trend, 25)

            # 1) buffer above lower band (safe fallback when atr==0)
            buffer = max(0.3 * (atr if atr else 0), 0.0025)
            near_lower = price_current <= (grid_lower + buffer)

            # 2) RSI acceptance: oversold OR reversal OR bullish divergence
            oversold_ok = False
            rsi_rev_ok = False
            rsi_div_ok = False
            try:
                oversold_ok = (rsi_1m is not None) and (rsi_1m <= (rsi_low + 5))

                # recent RSI series from sub1
                try:
                    rsis = sub1['rsi']
                except Exception:
                    rsis = talib.RSI(sub1['close'], timeperiod=GRID_RSI_PERIOD_1M)
                rsis = rsis.dropna() if hasattr(rsis, 'dropna') else rsis
                rsi_prev = float(rsis.iloc[-2]) if hasattr(rsis, 'iloc') and len(rsis) >= 2 else None
                rsi_cap = (rsi_low + 12)

                # reversal: RSI crosses above 50 from below (backtest mirror)
                if (rsi_prev is not None) and (rsi_1m is not None):
                    rsi_rev_ok = (rsi_prev < 50) and (rsi_1m >= 50)

                try:
                    lows = sub1['low'].dropna()
                    low_prev = float(lows.iloc[-2]) if len(lows) >= 2 else None
                    low_cur = float(lows.iloc[-1]) if len(lows) >= 1 else None
                    rsi_div_ok = (low_cur is not None and low_prev is not None and rsi_prev is not None and
                                  (low_cur < low_prev) and (rsi_1m is not None) and (rsi_1m > rsi_prev) and (rsi_1m <= rsi_cap))
                except Exception:
                    rsi_div_ok = False
            except Exception:
                oversold_ok = False
                rsi_rev_ok = False
                rsi_div_ok = False

            rsi_ok = oversold_ok or rsi_rev_ok or rsi_div_ok

            trend_check = (trend in ['osc_bull', 'bull_trend'] and rsi_5m > 45) or \
                          (trend in ['osc_bear', 'boll_divergence_down'] and rsi_5m < 55)

            # momentum & volume spike
            rebound = False
            vol_ok = False
            try:
                closes = sub1['close'].dropna()
                last = float(closes.iloc[-1])
                prev = float(closes.iloc[-2]) if len(closes) >= 2 else None
                rebound = (prev is not None and last > prev)
                vols = sub1['volume'].dropna()
                if len(vols) >= 6:
                    window = vols.iloc[-6:-1]
                    recent_mean = window.mean()
                    recent_median = window.median()
                    rmax = window.max()
                    mean_up = recent_mean * 1.05
                    med_up = recent_median * 1.01
                    max_up = rmax * 0.95
                    threshold = max(mean_up, med_up, max_up)
                    vol_ok = vols.iloc[-1] >= max(threshold, 0)
            except Exception:
                rebound = False
                vol_ok = False

            buy_signal = near_lower and rsi_ok and (trend_check or rebound or vol_ok)
            if not buy_signal:
                i += 1
                continue

            # Determine target & stop at signal time (use buffered TP level like live)
            tp_offset = max(TAKE_PROFIT_ATR_OFFSET * (atr if atr else 0), TAKE_PROFIT_MIN_OFFSET)
            target = (grid_upper - tp_offset) if grid_upper is not None else None
            # ensure target logically above current price
            if target is not None and target <= price_current:
                target = price_current + 1e-6
            stop, _ = compute_stop_loss(price_current, atr, grid_lower)
            if target is None or stop is None or np.isnan(target) or np.isnan(stop):
                i += 1
                continue

            # Walk forward to evaluate outcome
            forward = df_1m.iloc[i+1:min(i+1+lookahead, len(df_1m))]
            outcome = None
            for _, row in forward.iterrows():
                try:
                    lo = float(row['low'])
                    hi = float(row['high'])
                except Exception:
                    continue
                if lo <= stop:
                    outcome = 'loss'
                    break
                if hi >= target:
                    outcome = 'win'
                    break

            if outcome is None:
                unresolved += 1
            elif outcome == 'win':
                wins += 1
                risk = max(price_current - stop, 1e-6)
                reward = max(target - price_current, 0.0)
                rr_list.append(reward / risk)
            else:
                losses += 1
                rr_list.append(-1.0)  # standardized as -1 risk unit

            # Skip ahead past the evaluated window to avoid overlapping trades
            i += lookahead

        total = wins + losses
        win_rate = (wins / total) if total > 0 else 0.0
        avg_rr = (sum([r for r in rr_list if r > 0]) / max(wins, 1)) if wins > 0 else 0.0
        expectancy = win_rate * avg_rr - (1 - win_rate) * 1.0  # per risk unit

        result = {
            'samples': len(df_1m),
            'signals_evaluated': total,
            'wins': wins,
            'losses': losses,
            'unresolved': unresolved,
            'win_rate': win_rate,
            'avg_reward_risk': avg_rr,
            'expectancy_per_risk': expectancy
        }

        print(f"ğŸ“Š pro1 å›æµ‹: æ ·æœ¬={result['samples']} | è¯„ä¼°ä¿¡å·={result['signals_evaluated']} | èƒœ={wins} è´Ÿ={losses} æœªåˆ¤å®š={unresolved}")
        print(f"   èƒœç‡={win_rate:.2%} | å¹³å‡ç›ˆåˆ©é£é™©æ¯”={avg_rr:.2f} | æœŸæœ›å€¼(æ¯é£é™©å•ä½)={expectancy:.2f}")
        return result
    except Exception as e:
        print(f"âŒ backtest_pro1 å¼‚å¸¸ï¼š{e}")
        return None

# ====================== æµ‹è¯•å‡½æ•° ======================

def test_order_tracking():
    """æµ‹è¯•è®¢å•è·Ÿè¸ªå’Œäº¤æ˜“é—­ç¯åŠŸèƒ½"""
    global current_position, open_orders, closed_positions
    
    print("ğŸ§ª å¼€å§‹æµ‹è¯•è®¢å•è·Ÿè¸ªå’Œäº¤æ˜“é—­ç¯åŠŸèƒ½...")
    
    # é‡ç½®æµ‹è¯•çŠ¶æ€
    current_position = 0
    open_orders.clear()
    closed_positions.clear()
    
    # æ¨¡æ‹Ÿä¹°å…¥æ“ä½œ
    print("ğŸ“ æ¨¡æ‹Ÿä¹°å…¥æ“ä½œ...")
    place_tiger_order('BUY', 1, 100.0)
    place_tiger_order('BUY', 1, 102.0)
    place_tiger_order('BUY', 1, 104.0)
    
    print(f"ğŸ“Š ä¹°å…¥åçŠ¶æ€: æŒä»“={current_position}, å¾…å¹³ä»“è®¢å•={len(open_orders)}, å·²å¹³ä»“={len(closed_positions)}")
    
    # éªŒè¯ä¹°å…¥æ“ä½œæ˜¯å¦æ­£ç¡®è®°å½•
    assert current_position == 3, f"é¢„æœŸæŒä»“3æ‰‹ï¼Œå®é™…{current_position}æ‰‹"
    assert len(open_orders) >= 3, f"é¢„æœŸå¾…å¹³ä»“è®¢å•>=3ä¸ªï¼Œå®é™…{len(open_orders)}ä¸ª"  # æ²™ç®±æ¨¡å¼ä¸‹å¯èƒ½æ²¡æœ‰å®Œå…¨è®°å½•
    assert len(closed_positions) == 0, f"é¢„æœŸå·²å¹³ä»“0ä¸ªï¼Œå®é™…{len(closed_positions)}ä¸ª"
    
    # æ¨¡æ‹Ÿå–å‡ºæ“ä½œ
    print("ğŸ“ æ¨¡æ‹Ÿå–å‡ºæ“ä½œ...")
    place_tiger_order('SELL', 2, 108.0)  # å–å‡º2æ‰‹
    
    print(f"ğŸ“Š å–å‡ºåçŠ¶æ€: æŒä»“={current_position}, å¾…å¹³ä»“è®¢å•={len(open_orders)}, å·²å¹³ä»“={len(closed_positions)}")
    
    # éªŒè¯å–å‡ºæ“ä½œæ˜¯å¦æ­£ç¡®è®°å½•
    assert current_position == 1, f"é¢„æœŸæŒä»“1æ‰‹ï¼Œå®é™…{current_position}æ‰‹"
    assert len(closed_positions) >= 2, f"é¢„æœŸå·²å¹³ä»“>=2ä¸ªï¼Œå®é™…{len(closed_positions)}ä¸ª"  # æ²™ç®±æ¨¡å¼ä¸‹å¯èƒ½æ²¡æœ‰å®Œå…¨è®°å½•
    
    # å–å‡ºå‰©ä½™æŒä»“
    place_tiger_order('SELL', 1, 110.0)
    
    print(f"ğŸ“Š å…¨éƒ¨å–å‡ºåçŠ¶æ€: æŒä»“={current_position}, å¾…å¹³ä»“è®¢å•={len(open_orders)}, å·²å¹³ä»“={len(closed_positions)}")
    
    # éªŒè¯æ‰€æœ‰æŒä»“éƒ½å·²å¹³ä»“
    assert current_position == 0, f"é¢„æœŸæŒä»“0æ‰‹ï¼Œå®é™…{current_position}æ‰‹"
    assert len(closed_positions) >= 3, f"é¢„æœŸå·²å¹³ä»“>=3ä¸ªï¼Œå®é™…{len(closed_positions)}ä¸ª"
    
    print("âœ… è®¢å•è·Ÿè¸ªå’Œäº¤æ˜“é—­ç¯åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼")
    
    # æ˜¾ç¤ºäº¤æ˜“è¯¦æƒ…
    for i, trade in enumerate(closed_positions):
        profit = trade['profit']
        print(f"ğŸ“ˆ äº¤æ˜“{i+1}: ä¹°å…¥ä»· {trade['buy_price']}, å–å‡ºä»· {trade['sell_price']}, ç›ˆäº: {profit:.2f}USD")


def test_position_management():
    """æµ‹è¯•æŒä»“ç®¡ç†åŠŸèƒ½"""
    global current_position, position_entry_times, position_entry_prices
    
    print("\nğŸ§ª å¼€å§‹æµ‹è¯•æŒä»“ç®¡ç†åŠŸèƒ½...")
    
    # é‡ç½®æµ‹è¯•çŠ¶æ€
    current_position = 0
    position_entry_times.clear()
    position_entry_prices.clear()
    
    # æ¨¡æ‹Ÿä¹°å…¥æ“ä½œ
    place_tiger_order('BUY', 1, 50.0)
    place_tiger_order('BUY', 1, 52.0)
    place_tiger_order('BUY', 1, 54.0)
    
    # éªŒè¯æŒä»“å’Œä»·æ ¼è®°å½•
    assert current_position == 3, f"é¢„æœŸæŒä»“3æ‰‹ï¼Œå®é™…{current_position}æ‰‹"
    assert len(position_entry_prices) == 3, f"é¢„æœŸæŒä»“ä»·æ ¼è®°å½•3ä¸ªï¼Œå®é™…{len(position_entry_prices)}ä¸ª"
    
    # æ¨¡æ‹Ÿå–å‡ºæ“ä½œ
    place_tiger_order('SELL', 1, 58.0)
    
    # éªŒè¯æŒä»“å‡å°‘
    assert current_position == 2, f"é¢„æœŸæŒä»“2æ‰‹ï¼Œå®é™…{current_position}æ‰‹"
    
    print("âœ… æŒä»“ç®¡ç†åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼")


def test_risk_control():
    """æµ‹è¯•é£æ§åŠŸèƒ½"""
    global current_position
    
    print("\nğŸ§ª å¼€å§‹æµ‹è¯•é£æ§åŠŸèƒ½...")
    
    # é‡ç½®æµ‹è¯•çŠ¶æ€
    current_position = 0
    
    # è®¾ç½®æœ€å¤§æŒä»“ä¸º3
    global GRID_MAX_POSITION
    original_max_pos = GRID_MAX_POSITION
    GRID_MAX_POSITION = 3
    
    # ä¹°å…¥è¾¾åˆ°æœ€å¤§æŒä»“
    place_tiger_order('BUY', 1, 60.0)
    place_tiger_order('BUY', 1, 62.0)
    place_tiger_order('BUY', 1, 64.0)
    
    # å°è¯•è¶…è¿‡æœ€å¤§æŒä»“
    result = check_risk_control(66.0, 'BUY')
    assert result == False, "åº”å½“æ‹’ç»è¶…è¿‡æœ€å¤§æŒä»“çš„ä¹°å…¥"
    
    # æ¢å¤åŸå§‹è®¾ç½®
    GRID_MAX_POSITION = original_max_pos
    
    print("âœ… é£æ§åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼")


def run_tests():
    """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
    print("ğŸš€ å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...")
    
    test_order_tracking()
    test_position_management()
    test_risk_control()
    
    print("\nğŸ‰ æ‰€æœ‰æµ‹è¯•å®Œæˆï¼")
    
    # é‡ç½®ä¸ºç”Ÿäº§ç¯å¢ƒå˜é‡
    global current_position, open_orders, closed_positions, position_entry_times, position_entry_prices
    current_position = 0
    open_orders.clear()
    closed_positions.clear()
    position_entry_times.clear()
    position_entry_prices.clear()


# ====================== ä¸»ç¨‹åº ======================
if __name__ == "__main__":
    # æ£€æŸ¥æ˜¯å¦è¿è¡Œæµ‹è¯•
    if len(sys.argv) > 2 and sys.argv[2] == 'test':
        run_tests()
        exit(0)
    
    # 1. éªŒè¯APIè¿æ¥
    if not verify_api_connection():
        exit(1)
    
    # 2. å¯åŠ¨ç½‘æ ¼ç­–ç•¥
    try:
        # Optional backtest mode: pass second arg 'backtest' to run once
        if len(sys.argv) > 2 and sys.argv[2].lower() == 'backtest':
            print("ğŸš€ è¿è¡Œ pro1 å›æµ‹ ...")
            backtest_grid_trading_strategy_pro1(FUTURE_SYMBOL, bars_1m=3000, bars_5m=1200, lookahead=180)
        else:
            print("ğŸš€ å¯åŠ¨ç½‘æ ¼å¤„ç†ï¼‰...")
            while True:
                #grid_trading_strategy()
                grid_trading_strategy_pro1()
                #boll1m_grid_strategy()
                
                # æ¯æ¬¡å¾ªç¯åæ£€æŸ¥ä¸»åŠ¨æ­¢ç›ˆ
                # æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬å·²ç»åˆ†åˆ«åœ¨å„ä¸ªç­–ç•¥å‡½æ•°ä¸­è°ƒç”¨äº†check_active_take_profits
                # æ‰€ä»¥è¿™é‡Œä¸éœ€è¦é‡å¤è°ƒç”¨
                
                time.sleep(10)  # 
    except KeyboardInterrupt:
        print("ğŸ›‘ ç”¨æˆ·ç»ˆæ­¢ç¨‹åº")
    except Exception as e:
        print(f"âŒ ç¨‹åºå¼‚å¸¸ï¼š{e}")
    finally:
        # å¹³ä»“æ‰€æœ‰æŒä»“ï¼ˆå¯é€‰ï¼Œå®ç›˜è°¨æ…æ“ä½œï¼‰
        '''
        if current_position > 0:
            print(f"âš ï¸ ç¨‹åºé€€å‡ºï¼Œå¹³ä»“{current_position}æ‰‹æŒä»“")
            latest_price = get_kline_data(FUTURE_SYMBOL, '1min', count=1)['close'].iloc[-1]
            place_tiger_order('SELL', current_position, latest_price)
        '''    
        print("âœ… ç¨‹åºç»“æŸ")

        print("âœ… ç¨‹åºç»“æŸ")
def compute_stop_loss(price: float, atr_value: float, grid_lower_val: float):
    """è®¡ç®—æ­¢æŸä»·æ ¼å’Œé¢„æœŸæŸå¤±
    Args:
        price: å½“å‰ä»·æ ¼æˆ–å…¥åœºä»·æ ¼
        atr_value: ATRå€¼
        grid_lower_val: ç½‘æ ¼ä¸‹è½¨å€¼
    
    Returns:
        tuple: (stop_loss_price, projected_loss)
    """
    # ä½¿ç”¨ATRä½œä¸ºåŸºç¡€ï¼Œç»“åˆç½‘æ ¼ä¸‹è½¨æ¥è®¡ç®—æ­¢æŸ
    # é€šå¸¸æ­¢æŸè®¾åœ¨ç½‘æ ¼ä¸‹è½¨ä¹‹ä¸‹ä¸€å®šè·ç¦»ï¼Œä»¥é˜²æ­¢ä»·æ ¼è·Œç ´æ”¯æ’‘ä½
    atr_based_stop = max(0.5 * (atr_value if atr_value else 0), 0.02)  # ATRçš„ä¸€åŠï¼Œæœ€ä½0.02
    
    # ç»“æ„æ€§æ­¢æŸï¼šåŸºäºç½‘æ ¼ä¸‹è½¨
    structural_stop = max(0.05, price - grid_lower_val)  # ç½‘æ ¼ä¸‹è½¨åŸºç¡€ä¸Šçš„å®‰å…¨è·ç¦»
    
    # å•ç¬”æœ€å¤§äºæŸé™åˆ¶
    max_loss_per_unit = 0.1  # æœ€å¤§å•ä½äºæŸé™åˆ¶
    
    # è®¡ç®—ç»¼åˆæ­¢æŸ
    stop_distance = max(atr_based_stop, structural_stop, 0.05)  # è‡³å°‘0.05çš„æ­¢æŸè·ç¦»
    
    # è®¡ç®—æ­¢æŸä»·æ ¼
    stop_loss_price = price - stop_distance
    
    # è®¡ç®—é¢„æœŸæŸå¤±
    projected_loss = stop_distance * FUTURE_MULTIPLIER
    
    # è¿”å›æ­¢æŸä»·æ ¼å’Œé¢„æœŸæŸå¤±
    return stop_loss_price, projected_loss


def check_risk_control(price, side):
    """Basic risk control checks used by strategies and tests.

    Returns True if a trade of given `side` at `price` is allowed under
    simple rules (max position, daily loss, sane price).
    """
    global today, daily_loss, current_position

    # reset daily loss when date changes
    try:
        if today != datetime.now().date():
            today = datetime.now().date()
            daily_loss = 0
    except Exception:
        pass

    # basic validation of inputs
    try:
        if price is None:
            return False
        if not (isinstance(price, (int, float))):
            return False
        if math.isinf(price) or math.isnan(price):
            return False
        if price <= 0:
            return False
    except Exception:
        return False

    if side not in ('BUY', 'SELL'):
        return False

    # If we've already hit daily loss limit, block further buys
    if daily_loss >= DAILY_LOSS_LIMIT:
        return False

    # Prevent buys beyond max position
    if side == 'BUY' and current_position >= GRID_MAX_POSITION:
        return False

    # conservative per-trade loss check: estimate stop loss and projected loss
    try:
        stop_price, proj_loss = compute_stop_loss(price, atr_5m if atr_5m is not None else 0, grid_lower)
        if proj_loss is None:
            return False
        if proj_loss > SINGLE_TRADE_LOSS or proj_loss > MAX_SINGLE_LOSS:
            return False
    except Exception:
        # if estimation fails, be conservative and allow None/False depending on tests
        return True

    return True


# ====================== æ ¸å¿ƒå·¥å…·å‡½æ•° ======================
def get_timestamp():
    """ç”ŸæˆAPIç­¾åæ‰€éœ€çš„æ—¶é—´æˆ³"""
    return str(int(time.time() * 1000))  # è¿”å›å­—ç¬¦ä¸²è€Œä¸æ˜¯æ•´æ•°

# ====================== ç­–ç•¥å…¨å±€å˜é‡ ======================
current_position = 0           # å½“å‰æŒä»“æ‰‹æ•°
daily_loss = 0                 # å½“æ—¥ç´¯è®¡äºæŸ

# æ­¢ç›ˆå‚æ•°ï¼ˆå¯é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æˆ–ç¯å¢ƒå˜é‡è°ƒæ•´ï¼‰
TAKE_PROFIT_TIMEOUT = 15       # æ­¢ç›ˆå•è¶…æ—¶ï¼ˆåˆ†é’Ÿï¼‰
MIN_PROFIT_RATIO = float(0.02) # æœ€ä½ä¸»åŠ¨æ­¢ç›ˆæ¯”ä¾‹ï¼ˆ2%ï¼‰

# è¿è¡Œç¯å¢ƒæ ‡è¯†ï¼ˆç”¨äºæ—¥å¿—/æ¨¡æ‹Ÿä¸‹å•æç¤ºï¼‰ï¼Œä»¥åŠä»Šæ—¥æ—¥æœŸç”¨äºæ¯æ—¥äºæŸé‡ç½®
RUN_ENV = 'sandbox' if count_type == 'd' else 'production'
today = datetime.now().date()


def check_risk_control(price, side):
    """Basic risk control checks used by strategies and tests.

    Returns True if a trade of given `side` at `price` is allowed under
    simple rules (max position, daily loss, sane price).
    """
    global today, daily_loss, current_position

    # reset daily loss when date changes
    try:
        if today != datetime.now().date():
            today = datetime.now().date()
            daily_loss = 0
    except Exception:
        pass

    # basic validation of inputs
    try:
        if price is None:
            return False
        if not (isinstance(price, (int, float))):
            return False
        if math.isinf(price) or math.isnan(price):
            return False
        if price <= 0:
            return False
    except Exception:
        return False

    if side not in ('BUY', 'SELL'):
        return False

    # If we've already hit daily loss limit, block further buys
    if daily_loss >= DAILY_LOSS_LIMIT:
        return False

    # Prevent buys beyond max position
    if side == 'BUY' and current_position >= GRID_MAX_POSITION:
        return False

    # conservative per-trade loss check: estimate stop loss and projected loss
    try:
        stop_price, proj_loss = compute_stop_loss(price, atr_5m if atr_5m is not None else 0, grid_lower)
        if proj_loss is None:
            return False
        if proj_loss > SINGLE_TRADE_LOSS or proj_loss > MAX_SINGLE_LOSS:
            return False
    except Exception:
        # if estimation fails, be conservative and allow None/False depending on tests
        return True

    return True


# ====================== æ ¸å¿ƒå·¥å…·å‡½æ•° ======================
def get_timestamp():
    """Returns the current timestamp in milliseconds."""
    return int(time.time() * 1000)


# ====================== ç­–ç•¥å…¨å±€å˜é‡ ======================
current_position = 0           # å½“å‰æŒä»“æ‰‹æ•°
daily_loss = 0                 # å½“æ—¥ç´¯è®¡äºæŸ
grid_upper = 0                 # ç½‘æ ¼ä¸Šè½¨
grid_lower = 0                 # ç½‘æ ¼ä¸‹è½¨
last_boll_width = 0            # ä¸Šä¸€æ¬¡BOLLè½¨é“é—´è·
atr_5m = 0                     # 5åˆ†é’ŸATRå€¼
is_boll_divergence = False     # æ˜¯å¦BOLLå‘æ•£

# æ–°å¢è®¢å•çŠ¶æ€è·Ÿè¸ª
open_orders = {}               # è®°å½•å¾…å¹³ä»“çš„ä¹°å• {order_id: {'quantity': qty, 'price': price, 'timestamp': ts, 'tech_params': {}, 'reason': ''}}
closed_positions = {}          # å·²å¹³ä»“çš„äº¤æ˜“è®°å½• {order_id: {'buy_order_id': id, 'sell_order_id': id, 'buy_price': bp, 'sell_price': sp, 'analysis': {...}}, ...}


# æ–°å¢æ­¢ç›ˆç›¸å…³å…¨å±€å˜é‡
position_entry_times = {}      # è®°å½•æ¯ä¸ªæŒä»“çš„å…¥åœºæ—¶é—´ {position_id: timestamp}
position_entry_prices = {}     # è®°å½•æ¯ä¸ªæŒä»“çš„å…¥åœºä»·æ ¼ {position_id: entry_price}
active_take_profit_orders = {} # è·Ÿè¸ªå·²æäº¤çš„æ­¢ç›ˆå• {position_id: {'target_price': price, 'submit_time': timestamp}

FUTURE_TICK_SIZE = 0.01  # æœ€å°å˜åŠ¨ä»·ä½
MIN_TICK = 0.01  # æœ€å°å˜åŠ¨ä»·ä½
FUTURE_EXPIRE_DATE = '2026-03-28'  # åˆçº¦åˆ°æœŸæ—¥

# ç­–ç•¥å‚æ•°
price_current = 0
rsi_1m = 0
rsi_5m = 0
buffer = 0
threshold = 0
active_positions = {}
pending_orders = {}

# æ­¢ç›ˆå‚æ•°ï¼ˆå¯é€šè¿‡å‘½ä»¤è¡Œå‚æ•°æˆ–ç¯å¢ƒå˜é‡è°ƒæ•´ï¼‰
TAKE_PROFIT_TIMEOUT = 15       # æ­¢ç›ˆå•è¶…æ—¶ï¼ˆåˆ†é’Ÿï¼‰
MIN_PROFIT_RATIO = float(0.02) # æœ€ä½ä¸»åŠ¨æ­¢ç›ˆæ¯”ä¾‹ï¼ˆ2%ï¼‰

# è¿è¡Œç¯å¢ƒæ ‡è¯†ï¼ˆç”¨äºæ—¥å¿—/æ¨¡æ‹Ÿä¸‹å•æç¤ºï¼‰ï¼Œä»¥åŠä»Šæ—¥æ—¥æœŸç”¨äºæ¯æ—¥äºæŸé‡ç½®
RUN_ENV = 'sandbox' if count_type == 'd' else 'production'
today = datetime.now().date()


def check_risk_control(price, side):
    """Basic risk control checks used by strategies and tests.

    Returns True if a trade of given `side` at `price` is allowed under
    simple rules (max position, daily loss, sane price).
    """
    global today, daily_loss, current_position

    # reset daily loss when date changes
    try:
        if today != datetime.now().date():
            today = datetime.now().date()
            daily_loss = 0
    except Exception:
        pass

    # basic validation of inputs
    try:
        if price is None:
            return False
        if not (isinstance(price, (int, float))):
            return False
        if math.isinf(price) or math.isnan(price):
            return False
        if price <= 0:
            return False
    except Exception:
        return False

    if side not in ('BUY', 'SELL'):
        return False

    # If we've already hit daily loss limit, block further buys
    if daily_loss >= DAILY_LOSS_LIMIT:
        return False

    # Prevent buys beyond max position
    if side == 'BUY' and current_position >= GRID_MAX_POSITION:
        return False

    # conservative per-trade loss check: estimate stop loss and projected loss
    try:
        stop_price, proj_loss = compute_stop_loss(price, atr_5m if atr_5m is not None else 0, grid_lower)
        if proj_loss is None:
            return False
        if proj_loss > SINGLE_TRADE_LOSS or proj_loss > MAX_SINGLE_LOSS:
            return False
    except Exception:
        # if estimation fails, be conservative and allow None/False depending on tests
        return True

    return True

FUTURE_TICK_SIZE = 0.01  # æœ€å°å˜åŠ¨ä»·ä½
MIN_TICK = 0.01  # æœ€å°å˜åŠ¨ä»·ä½
FUTURE_EXPIRE_DATE = '2026-03-28'  # åˆçº¦åˆ°æœŸæ—¥

# ç­–ç•¥å‚æ•°
price_current = 0
rsi_1m = 0
rsi_5m = 0
buffer = 0
threshold = 0
active_positions = {}
pending_orders = {}

