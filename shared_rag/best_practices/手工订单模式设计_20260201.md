# 手工订单模式设计

**作者**: system  
**时间**: 2026-02-01  
**类别**: best_practices  
**标签**: manual_order, backtest, realtime, trading

---

## 摘要

软件在监控实时数据时，用户可输入手工订单指令，采用 A/B/C 形态 + D 止损 + E 止盈。支持做多和做空，提供回测方式验证。

---

## 1. 指令格式（字段名已改为有意义命名）

### 做多
- **trigger**：低点（价格下降到 trigger 后触发）
- **confirm**：回升点（价格回升到 confirm 后确认支撑）
- **entry**：建仓点（在 entry 开多）
- **stop_loss**：止损点（价格跌破则平仓）
- **take_profit**：止盈点（价格涨至则平仓）
- **约束**：trigger < confirm ≤ entry，stop_loss < entry，take_profit > entry

### 做空
- **trigger**：高点（价格上升到 trigger 后触发）
- **confirm**：回落点（价格回落到 confirm 后确认阻力）
- **entry**：建仓点（在 entry 开空）
- **stop_loss**：止损点（价格涨破则平仓）
- **take_profit**：止盈点（价格跌至则平仓）
- **约束**：trigger > confirm ≥ entry，stop_loss > entry，take_profit < entry

（旧名 A/B/C/D/E 在 JSON 中仍兼容读取。）

### 直接下单（不用 trigger/confirm）

当 trigger/confirm 无效或不想用时，可设 **direct_entry: true**，仅用 **entry、stop_loss、take_profit**：

- 逻辑：不等 trigger/confirm，价格触及 **entry** 即建仓，再按 **stop_loss** / **take_profit** 平仓。
- JSON 示例：`{"direction":"long","entry":28.9,"stop_loss":28.3,"take_profit":29.2,"direct_entry":true}`
- 回测：`python scripts/backtest_manual_order.py --long-direct 28.9 28.3 29.2`

---

## 2. 使用方式

### 回测
```bash
# 做多（trigger confirm entry stop_loss take_profit）
python scripts/backtest_manual_order.py --long 85 88 89 87 94

# 做空
python scripts/backtest_manual_order.py --short 95 92 91 93 88

# JSON（新名）
python scripts/backtest_manual_order.py --json '{"direction":"long","trigger":85,"confirm":88,"entry":89,"stop_loss":87,"take_profit":94}'
# 旧名 A/B/C/D/E 仍兼容
```

### 实时监控输入
将指令写入 `tigertrade/run/manual_orders.json`：

```json
{"direction": "long", "trigger": 28.5, "confirm": 28.8, "entry": 28.9, "stop_loss": 28.3, "take_profit": 29.2, "once": true}
```

**once 标记**：
- `true`（默认）：一次有效，建仓→平仓后该指令失效
- `false`：多次有效，每次 A→B→C 出现都会重新建仓（适合网格类策略）

**两条完全相同的记录**：会当作两条独立订单，分别建仓（两个仓位）。

**状态刷新**：监控进程每次 `on_price_update` 后会将状态写入 `tigertrade/run/manual_orders_status.json`，用户可查看 `active`（待执行/持仓中）和 `closed`（已平仓及盈亏）。

**手工订单文件查询间隔**：`manual_orders.json` 在每次调用 `ManualOrderMonitor.on_price_update(...)` 时被读取一次（读后清空，避免重复执行）。若接入主循环，则查询间隔 = 主循环步长（例如 5 秒或 1 分钟一根 K 线）。单独运行带 Monitor 的脚本时，由该脚本的循环间隔决定。

**主循环内集成（同一线程）**：手工订单可与自动策略在同一线程内运行，避免两线程并发带来的变量竞争。设置环境变量 `USE_MANUAL_IN_MAIN_LOOP=1` 后，tiger1 主循环在每轮 `grid_trading_strategy_pro1()` 之后会取最新 1 分钟 K 线并调用 `ManualOrderMonitor.on_price_update(open, high, low, close, 0)`，与自动策略共用 `current_position`、`open_orders` 等全局变量。**注意**：若手工订单的 `on_fill` 回调里调用 `place_tiger_order`，会修改同一 `current_position`，需注意仓位合计。测试见 `tests/test_auto_manual_concurrent.py`（`test_main_loop_manual_integration_no_order`、`test_manual_and_auto_share_position_variable`）。

**风控与手工订单（总持仓、总止损是否一起算）**：是的，**一起算**。风控函数 `check_risk_control(price, side)` 使用的 `current_position`、`daily_loss` 与 `place_tiger_order` 更新的是同一套全局变量，因此自动订单和通过 `place_tiger_order` 下的手工订单在**总持仓、当日亏损、单笔止损**上是一起计算的。**但**：自动策略在下单前会先调用 `check_risk_control`，而手工订单若在 `on_fill` 里直接调用 `place_tiger_order`，**目前不会先经过** `check_risk_control`，可能出现「手工先下一单导致总持仓或日亏损超限、之后自动单被风控拦住」或「手工单独算一套风控就会算错」的情况。建议在接入手工下单时，在 `on_fill` 里**先调用** `tiger1.check_risk_control(entry_price, 'BUY')` 或 `check_risk_control(exit_price, 'SELL')`，通过后再 `place_tiger_order(..., source='manual')`，这样手工与自动就共用同一套风控逻辑。示例（建仓时先风控再下单）：

```python
import src.tiger1 as t1
def on_fill(order, price):
    side = 'BUY' if order.instruction.direction.value == 'long' else 'SELL'
    if not t1.check_risk_control(price, side):
        return  # 风控不通过，不下单
    t1.place_tiger_order(side, 1, price, source='manual')
```

或 Python 调用：
```python
from src.manual_order_mode import ManualOrderInstruction, Direction, save_manual_order
inst = ManualOrderInstruction(Direction.LONG, 28.5, 28.8, 28.9, 28.3, 29.2)
save_manual_order(inst)
```

---

## 3. 相关代码

| 模块 | 说明 |
|------|------|
| `src/manual_order_mode.py` | 指令格式、状态机、回测、实时监控 |
| `scripts/backtest_manual_order.py` | 回测脚本 |
| `tigertrade/run/manual_orders.json` | 实时监控时用户输入的订单文件 |
| `tigertrade/run/manual_orders_status.json` | 状态文件，监控进程每次更新后写入，供用户查看 active/closed 状态 |
| `tigertrade/run/order_log.jsonl` | **订单业务 LOG**：自动交易下单记录（用户只看此，不看运行日志） |
