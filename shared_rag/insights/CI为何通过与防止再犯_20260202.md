# CI/CD 为何通过、问题一犯再犯 —— 回溯与改进

**日期**: 2026-02-02  
**标签**: ci, regression, pytest, routine

---

## 一、现象

- 本地跑「例行」测试（`pytest tests/ -m "not real_api"`）曾出现失败：test_gpu_model_comparison 的 return 警告与特征维度 12≠10、place_take_profit_order 未定义 `e` 与 print mock、place_tiger_order 真实路径 is_mock_mode 等。
- DEMO 运行刷屏「Using device」。
- 疑问：**CI 为啥显示通过，这类问题却一犯再犯？**

---

## 二、根因回溯：CI 与本地为何不一致

### 2.1 命令不一致

| 维度 | 例行工作 / 本地 | CI（ci.yml） |
|------|------------------|--------------|
| 测试命令 | `pytest tests/ -m "not real_api"` | `pytest tests/test_feature_*.py` 与 `pytest tests/ --ignore=tests/test_feature_*.py`，**未加** `-m "not real_api"` |
| 环境变量 | 推荐 `PYTEST_DISABLE_PLUGIN_AUTOLOAD=1`（防 ROS 等插件干扰） | **未设置** |
| 是否同套用例 | 同一套用例，一次跑完 | 拆成 Feature 一步 + Unit 一步，**未用同一套标记** |

后果：

- CI 收集/运行的用例集合、顺序、环境与本地不完全一致。
- 本地依赖 `PYTEST_DISABLE_PLUGIN_AUTOLOAD=1` 才能稳定跑全量时，CI 未用该变量，可能多跑/少跑或受插件影响，出现「本地挂 CI 过」或「CI 挂本地过」。
- 未统一使用 `-m "not real_api"`，CI 与例行清单不一致，容易产生「以为和 CI 一样」的误判。

### 2.2 回归门禁只覆盖部分路径

- CI 已有 **Regression guard**：OrderExecutor 回退 + tiger1 __main__ 冒烟（见 `CI与feature测试防低级回归_20260201.md`）。
- 本次暴露的问题不在该门禁内：
  - place_take_profit_order 的 `e` 未定义、print 被 mock 时未返回；
  - place_tiger_order 在 is_mock_mode 下不调用真实 API，单测却期望「真实路径失败」；
  - test_gpu_model_comparison 的 return 与特征维度断言过严。
- 因此：**CI 通过 ≠ 全量用例与本地一致通过**，只是当前门禁的那几条路径过了。

### 2.3 无对「DEMO 体验」的检查

- 「Using device」刷屏属于体验/日志问题，没有在 CI 里做：
  - 策略初始化时禁止重复打印设备信息，或
  - 任何「DEMO 冒烟 + 日志行数/关键字」检查。
- 所以这类问题只能靠人工跑 DEMO 发现，容易一犯再犯。

---

## 三、为何会「一犯再犯」

1. **CI 与例行命令不统一**：推前本地按例行跑的是 A 命令，CI 跑的是 B 命令，两边不等价，回归没在 CI 上暴露。
2. **门禁只补了历史坑**：Regression guard 只针对「check_risk_control / __main__」类问题，没有把「tiger1 边界路径、策略单测与 mock 假设」等纳入必跑门禁。
3. **策略/DEMO 侧无门禁**：策略初始化打印、DEMO 日志量等没有自动化约束，改完容易再次引入类似问题。

---

## 四、改进措施（防止再犯）

### 4.1 统一 CI 与例行测试命令（必做）

- 在 **ci.yml** 中：
  - 与例行保持一致：使用 **`-m "not real_api"`**；
  - 设置 **`PYTEST_DISABLE_PLUGIN_AUTOLOAD=1`**（与本地一致，避免插件干扰）。
- 可选：增加一步 **「全量门禁」**：用与例行完全相同的命令跑一遍全量（例如 `pytest tests/ -m "not real_api"`），失败即 CI 失败，保证「本地过 = CI 过」。

### 4.2 例行清单与文档明确「推前必跑」

- 在 **例行工作清单** 与 **状态页刷新规范** 中写清：
  - **推代码前**（含状态页、策略、tiger1 等）：必须在本地执行与 CI **相同** 的测试命令（见 4.1），通过后再推送。
- 建议在 README 或 docs 里写一句：**CI 通过条件 = 本地执行 `PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 python -m pytest tests/ -m "not real_api"` 通过。**

### 4.3 策略/DEMO 侧可做的小约束

- 策略初始化时 **不要重复打印设备信息**（已去掉 MoE/LLM 的 "Using device"）；后续新增策略也避免在循环/高频路径里打设备信息。
- 若有条件，可加一条「DEMO 冒烟」job：跑几秒 DEMO，对 stderr 行数或关键字做简单校验（防刷屏类问题再次引入）。

### 4.4 小结表

| 问题类型           | CI 为何没拦住           | 防止再犯 |
|--------------------|-------------------------|----------|
| 命令不一致         | CI 未用 `-m "not real_api"` 与 PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 | CI 与例行用同一套命令 |
| 门禁覆盖不全       | Regression guard 只覆盖部分路径 | 全量门禁一步 + 关键单测纳入 guard |
| DEMO/策略刷屏      | 无 DEMO 或日志检查      | 策略少打设备信息；可选 DEMO 冒烟检查 |

---

参见：`CI与feature测试防低级回归_20260201.md`、`.github/workflows/ci.yml`、`shared_rag/best_practices/例行工作清单_agent必读.md`。
